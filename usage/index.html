<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Examples - IXWebSocket</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css">

        <script src="../js/jquery-1.10.2.min.js" defer></script>
        <script src="../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">IXWebSocket</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href=".." class="nav-link">Home</a>
                            </li>
                            <li class="navitem">
                                <a href="../CHANGELOG/" class="nav-link">Changelog</a>
                            </li>
                            <li class="navitem">
                                <a href="../build/" class="nav-link">Build</a>
                            </li>
                            <li class="navitem">
                                <a href="../design/" class="nav-link">Design</a>
                            </li>
                            <li class="navitem">
                                <a href="../packages/" class="nav-link">Packages</a>
                            </li>
                            <li class="navitem">
                                <a href="../performance/" class="nav-link">Performance</a>
                            </li>
                            <li class="navitem active">
                                <a href="./" class="nav-link">Examples</a>
                            </li>
                            <li class="navitem">
                                <a href="../ws/" class="nav-link">Ws</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../performance/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../ws/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#examples" class="nav-link">Examples</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#windows-note" class="nav-link">Windows note</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#websocket-client-api" class="nav-link">WebSocket client API</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#handshake-timeout" class="nav-link">Handshake timeout</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#websocket-server-api" class="nav-link">WebSocket server API</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#http-client-api" class="nav-link">HTTP client API</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#http-server-api" class="nav-link">HTTP server API</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#tls-support-and-configuration" class="nav-link">TLS support and configuration</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="examples">Examples</h1>
<p>The <a href="https://github.com/machinezone/IXWebSocket/tree/master/ws"><em>ws</em></a> folder countains many interactive programs for chat, <a href="https://github.com/machinezone/IXWebSocket/blob/master/ws/ws_send.cpp">file transfers</a>, <a href="https://github.com/machinezone/IXWebSocket/blob/master/ws/ws_http_client.cpp">curl like</a> http clients, demonstrating client and server usage.</p>
<h2 id="windows-note">Windows note</h2>
<p>To use the network system on Windows, you need to initialize it once with <em>WSAStartup()</em> and clean it up with <em>WSACleanup()</em>. We have helpers for that which you can use, see below. This init would typically take place in your main function.</p>
<pre><code class="language-cpp">#include &lt;ixwebsocket/IXNetSystem.h&gt;

int main()
{
    ix::initNetSystem();

    ...

    ix::uninitNetSystem();
    return 0;
}
</code></pre>
<h2 id="websocket-client-api">WebSocket client API</h2>
<pre><code class="language-cpp">#include &lt;ixwebsocket/IXWebSocket.h&gt;

...

// Our websocket object
ix::WebSocket webSocket;

std::string url(&quot;ws://localhost:8080/&quot;);
webSocket.setUrl(url);

// Optional heart beat, sent every 45 seconds when there is not any traffic
// to make sure that load balancers do not kill an idle connection.
webSocket.setPingInterval(45);

// Per message deflate connection is enabled by default. You can tweak its parameters or disable it
webSocket.disablePerMessageDeflate();

// Setup a callback to be fired when a message or an event (open, close, error) is received
webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr&amp; msg)
    {
        if (msg-&gt;type == ix::WebSocketMessageType::Message)
        {
            std::cout &lt;&lt; msg-&gt;str &lt;&lt; std::endl;
        }
    }
);

// Now that our callback is setup, we can start our background thread and receive messages
webSocket.start();

// Send a message to the server (default to TEXT mode)
webSocket.send(&quot;hello world&quot;);

// The message can be sent in BINARY mode (useful if you send MsgPack data for example)
webSocket.sendBinary(&quot;some serialized binary data&quot;);

// ... finally ...

// Stop the connection
webSocket.stop()
</code></pre>
<h3 id="sending-messages">Sending messages</h3>
<p><code>WebSocketSendInfo result = websocket.send("foo")</code> will send a message.</p>
<p>If the connection was closed, sending will fail, and the success field of the result object  will be set to false. There could also be a compression error in which case the compressError field will be set to true. The payloadSize field and wireSize fields will tell you respectively how much bytes the message weight, and how many bytes were sent on the wire (potentially compressed + counting the message header (a few bytes).</p>
<p>There is an optional progress callback that can be passed in as the second argument. If a message is large it will be fragmented into chunks which will be sent independantly. Everytime the we can write a fragment into the OS network cache, the callback will be invoked. If a user wants to cancel a slow send, false should be returned from within the callback.</p>
<p>Here is an example code snippet copied from the ws send sub-command. Each fragment weights 32K, so the total integer is the wireSize divided by 32K. As an example if you are sending 32M of data, uncompressed, total will be 1000. current will be set to 0 for the first fragment, then 1, 2 etc...</p>
<pre><code>auto result =
    _webSocket.sendBinary(serializedMsg, [this, throttle](int current, int total) -&gt; bool {
        spdlog::info(&quot;ws_send: Step {} out of {}&quot;, current + 1, total);

        if (throttle)
        {
            std::chrono::duration&lt;double, std::milli&gt; duration(10);
            std::this_thread::sleep_for(duration);
        }

        return _connected;
    });
</code></pre>
<h3 id="readystate">ReadyState</h3>
<p><code>getReadyState()</code> returns the state of the connection. There are 4 possible states.</p>
<ol>
<li>ReadyState::Connecting - The connection is not yet open.</li>
<li>ReadyState::Open       - The connection is open and ready to communicate.</li>
<li>ReadyState::Closing    - The connection is in the process of closing.</li>
<li>ReadyState::Closed     - The connection is closed or could not be opened.</li>
</ol>
<h3 id="open-and-close-notifications">Open and Close notifications</h3>
<p>The onMessage event will be fired when the connection is opened or closed. This is similar to the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">JavaScript browser API</a>, which has <code>open</code> and <code>close</code> events notification that can be registered with the browser <code>addEventListener</code>.</p>
<pre><code class="language-cpp">webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr&amp; msg)
    {
        if (msg-&gt;type == ix::WebSocketMessageType::Open)
        {
            std::cout &lt;&lt; &quot;send greetings&quot; &lt;&lt; std::endl;

            // Headers can be inspected (pairs of string/string)
            std::cout &lt;&lt; &quot;Handshake Headers:&quot; &lt;&lt; std::endl;
            for (auto it : msg-&gt;headers)
            {
                std::cout &lt;&lt; it.first &lt;&lt; &quot;: &quot; &lt;&lt; it.second &lt;&lt; std::endl;
            }
        }
        else if (msg-&gt;type == ix::WebSocketMessageType::Close)
        {
            std::cout &lt;&lt; &quot;disconnected&quot; &lt;&lt; std::endl;

            // The server can send an explicit code and reason for closing.
            // This data can be accessed through the closeInfo object.
            std::cout &lt;&lt; msg-&gt;closeInfo.code &lt;&lt; std::endl;
            std::cout &lt;&lt; msg-&gt;closeInfo.reason &lt;&lt; std::endl;
        }
    }
);
</code></pre>
<h3 id="error-notification">Error notification</h3>
<p>A message will be fired when there is an error with the connection. The message type will be <code>ix::WebSocketMessageType::Error</code>. Multiple fields will be available on the event to describe the error.</p>
<pre><code class="language-cpp">webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr&amp; msg)
    {
        if (msg-&gt;type == ix::WebSocketMessageType::Error)
        {
            std::stringstream ss;
            ss &lt;&lt; &quot;Error: &quot;         &lt;&lt; msg-&gt;errorInfo.reason      &lt;&lt; std::endl;
            ss &lt;&lt; &quot;#retries: &quot;      &lt;&lt; msg-&gt;eventInfo.retries     &lt;&lt; std::endl;
            ss &lt;&lt; &quot;Wait time(ms): &quot; &lt;&lt; msg-&gt;eventInfo.wait_time   &lt;&lt; std::endl;
            ss &lt;&lt; &quot;HTTP Status: &quot;   &lt;&lt; msg-&gt;eventInfo.http_status &lt;&lt; std::endl;
            std::cout &lt;&lt; ss.str() &lt;&lt; std::endl;
        }
    }
);
</code></pre>
<h3 id="start-stop">start, stop</h3>
<ol>
<li><code>websocket.start()</code> connect to the remote server and starts the message receiving background thread.</li>
<li><code>websocket.stop()</code> disconnect from the remote server and closes the background thread.</li>
</ol>
<h3 id="configuring-the-remote-url">Configuring the remote url</h3>
<p>The url can be set and queried after a websocket object has been created. You will have to call <code>stop</code> and <code>start</code> if you want to disconnect and connect to that new url.</p>
<pre><code class="language-cpp">std::string url(&quot;wss://example.com&quot;);
websocket.configure(url);
</code></pre>
<h3 id="pingpong-support">Ping/Pong support</h3>
<p>Ping/pong messages are used to implement keep-alive. 2 message types exists to identify ping and pong messages. Note that when a ping message is received, a pong is instantly send back as requested by the WebSocket spec.</p>
<pre><code class="language-cpp">webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr&amp; msg)
    {
        if (msg-&gt;type == ix::WebSocketMessageType::Ping ||
            msg-&gt;type == ix::WebSocketMessageType::Pong)
        {
            std::cout &lt;&lt; &quot;pong data: &quot; &lt;&lt; msg-&gt;str &lt;&lt; std::endl;
        }
    }
);
</code></pre>
<p>A ping message can be sent to the server, with an optional data string.</p>
<pre><code class="language-cpp">websocket.ping(&quot;ping data, optional (empty string is ok): limited to 125 bytes long&quot;);
</code></pre>
<h3 id="heartbeat">Heartbeat.</h3>
<p>You can configure an optional heart beat / keep-alive, sent every 45 seconds
when there is no any traffic to make sure that load balancers do not kill an
idle connection.</p>
<pre><code class="language-cpp">webSocket.setPingInterval(45);
</code></pre>
<h3 id="supply-extra-http-headers">Supply extra HTTP headers.</h3>
<p>You can set extra HTTP headers to be sent during the WebSocket handshake.</p>
<pre><code class="language-cpp">WebSocketHttpHeaders headers;
headers[&quot;foo&quot;] = &quot;bar&quot;;
webSocket.setExtraHeaders(headers);
</code></pre>
<h3 id="subprotocols">Subprotocols</h3>
<p>You can specify subprotocols to be set during the WebSocket handshake. For more info you can refer to <a href="https://hpbn.co/websocket/#subprotocol-negotiation">this doc</a>.</p>
<pre><code class="language-cpp">webSocket.addSubprotocol(&quot;appProtocol-v1&quot;);
webSocket.addSubprotocol(&quot;appProtocol-v2&quot;);
</code></pre>
<p>The protocol that the server did accept is available in the open info <code>protocol</code> field.</p>
<pre><code class="language-cpp">std::cout &lt;&lt; &quot;protocol: &quot; &lt;&lt; msg-&gt;openInfo.protocol &lt;&lt; std::endl;
</code></pre>
<h3 id="automatic-reconnection">Automatic reconnection</h3>
<p>Automatic reconnection kicks in when the connection is disconnected without the user consent. This feature is on by default and can be turned off.</p>
<pre><code class="language-cpp">webSocket.enableAutomaticReconnection();  // turn on
webSocket.disableAutomaticReconnection(); // turn off
bool enabled = webSocket.isAutomaticReconnectionEnabled(); // query state
</code></pre>
<p>The technique to calculate wait time is called <a href="https://docs.aws.amazon.com/general/latest/gr/api-retries.html">exponential
backoff</a>. Here
are the default waiting times between attempts (from connecting with <code>ws connect ws://foo.com</code>)</p>
<pre><code>&gt; Connection error: Got bad status connecting to foo.com, status: 301, HTTP Status line: HTTP/1.1 301 Moved Permanently

#retries: 1
Wait time(ms): 100
#retries: 2
Wait time(ms): 200
#retries: 3
Wait time(ms): 400
#retries: 4
Wait time(ms): 800
#retries: 5
Wait time(ms): 1600
#retries: 6
Wait time(ms): 3200
#retries: 7
Wait time(ms): 6400
#retries: 8
Wait time(ms): 10000
</code></pre>
<p>The waiting time is capped by default at 10s between 2 attempts, but that value
can be changed and queried. The minimum waiting time can also be set.</p>
<pre><code class="language-cpp">webSocket.setMaxWaitBetweenReconnectionRetries(5 * 1000); // 5000ms = 5s
uint32_t m = webSocket.getMaxWaitBetweenReconnectionRetries();

webSocket.setMinWaitBetweenReconnectionRetries(1000); // 1000ms = 1s
uint32_t m = webSocket.getMinWaitBetweenReconnectionRetries();
</code></pre>
<h2 id="handshake-timeout">Handshake timeout</h2>
<p>You can control how long to wait until timing out while waiting for the websocket handshake to be performed.</p>
<pre><code>int handshakeTimeoutSecs = 1;
setHandshakeTimeout(handshakeTimeoutSecs);
</code></pre>
<h2 id="websocket-server-api">WebSocket server API</h2>
<h3 id="legacy-api">Legacy api</h3>
<p>This api was actually changed to take a weak_ptr<WebSocket> as the first argument to setOnConnectionCallback ; previously it would take a shared_ptr<WebSocket> which was creating cycles and then memory leaks problems.</p>
<pre><code class="language-cpp">#include &lt;ixwebsocket/IXWebSocketServer.h&gt;

...

// Run a server on localhost at a given port.
// Bound host name, max connections and listen backlog can also be passed in as parameters.
ix::WebSocketServer server(port);

server.setOnConnectionCallback(
    [&amp;server](std::weak_ptr&lt;WebSocket&gt; webSocket,
              std::shared_ptr&lt;ConnectionState&gt; connectionState)
    {
        std::cout &lt;&lt; &quot;Remote ip: &quot; &lt;&lt; connectionState-&gt;remoteIp &lt;&lt; std::endl;

        auto ws = webSocket.lock();
        if (ws)
        {
            ws-&gt;setOnMessageCallback(
                [webSocket, connectionState, &amp;server](const ix::WebSocketMessagePtr msg)
                {
                    if (msg-&gt;type == ix::WebSocketMessageType::Open)
                    {
                        std::cout &lt;&lt; &quot;New connection&quot; &lt;&lt; std::endl;

                        // A connection state object is available, and has a default id
                        // You can subclass ConnectionState and pass an alternate factory
                        // to override it. It is useful if you want to store custom
                        // attributes per connection (authenticated bool flag, attributes, etc...)
                        std::cout &lt;&lt; &quot;id: &quot; &lt;&lt; connectionState-&gt;getId() &lt;&lt; std::endl;

                        // The uri the client did connect to.
                        std::cout &lt;&lt; &quot;Uri: &quot; &lt;&lt; msg-&gt;openInfo.uri &lt;&lt; std::endl;

                        std::cout &lt;&lt; &quot;Headers:&quot; &lt;&lt; std::endl;
                        for (auto it : msg-&gt;openInfo.headers)
                        {
                            std::cout &lt;&lt; it.first &lt;&lt; &quot;: &quot; &lt;&lt; it.second &lt;&lt; std::endl;
                        }
                    }
                    else if (msg-&gt;type == ix::WebSocketMessageType::Message)
                    {
                        // For an echo server, we just send back to the client whatever was received by the server
                        // All connected clients are available in an std::set. See the broadcast cpp example.
                        // Second parameter tells whether we are sending the message in binary or text mode.
                        // Here we send it in the same mode as it was received.
                        auto ws = webSocket.lock();
                        if (ws)
                        {
                            ws-&gt;send(msg-&gt;str, msg-&gt;binary);
                        }
                    }
                }
            }
        );
    }
);

auto res = server.listen();
if (!res.first)
{
    // Error handling
    return 1;
}

// Per message deflate connection is enabled by default. It can be disabled
// which might be helpful when running on low power devices such as a Rasbery Pi
server.disablePerMessageDeflate();

// Run the server in the background. Server can be stoped by calling server.stop()
server.start();

// Block until server.stop() is called.
server.wait();

</code></pre>
<h3 id="new-api">New api</h3>
<p>The new API does not require to use 2 nested callbacks, which is a bit annoying. The real fix is that there was a memory leak due to a shared_ptr cycle, due to passing down a shared_ptr<WebSocket> down to the callbacks.</p>
<p>The webSocket reference is guaranteed to be always valid ; by design the callback will never be invoked with a null webSocket object.</p>
<pre><code class="language-cpp">#include &lt;ixwebsocket/IXWebSocketServer.h&gt;

...

// Run a server on localhost at a given port.
// Bound host name, max connections and listen backlog can also be passed in as parameters.
ix::WebSocketServer server(port);

server.setOnClientMessageCallback([](std::shared_ptr&lt;ix::ConnectionState&gt; connectionState, ix::WebSocket &amp; webSocket, const ix::WebSocketMessagePtr &amp; msg) {
    // The ConnectionState object contains information about the connection,
    // at this point only the client ip address and the port.
    std::cout &lt;&lt; &quot;Remote ip: &quot; &lt;&lt; connectionState-&gt;getRemoteIp() &lt;&lt; std::endl;

    if (msg-&gt;type == ix::WebSocketMessageType::Open)
    {
        std::cout &lt;&lt; &quot;New connection&quot; &lt;&lt; std::endl;

        // A connection state object is available, and has a default id
        // You can subclass ConnectionState and pass an alternate factory
        // to override it. It is useful if you want to store custom
        // attributes per connection (authenticated bool flag, attributes, etc...)
        std::cout &lt;&lt; &quot;id: &quot; &lt;&lt; connectionState-&gt;getId() &lt;&lt; std::endl;

        // The uri the client did connect to.
        std::cout &lt;&lt; &quot;Uri: &quot; &lt;&lt; msg-&gt;openInfo.uri &lt;&lt; std::endl;

        std::cout &lt;&lt; &quot;Headers:&quot; &lt;&lt; std::endl;
        for (auto it : msg-&gt;openInfo.headers)
        {
            std::cout &lt;&lt; &quot;\t&quot; &lt;&lt; it.first &lt;&lt; &quot;: &quot; &lt;&lt; it.second &lt;&lt; std::endl;
        }
    }
    else if (msg-&gt;type == ix::WebSocketMessageType::Message)
    {
        // For an echo server, we just send back to the client whatever was received by the server
        // All connected clients are available in an std::set. See the broadcast cpp example.
        // Second parameter tells whether we are sending the message in binary or text mode.
        // Here we send it in the same mode as it was received.
        std::cout &lt;&lt; &quot;Received: &quot; &lt;&lt; msg-&gt;str &lt;&lt; std::endl;

        webSocket.send(msg-&gt;str, msg-&gt;binary);
    }
});

auto res = server.listen();
if (!res.first)
{
    // Error handling
    return 1;
}

// Per message deflate connection is enabled by default. It can be disabled
// which might be helpful when running on low power devices such as a Rasbery Pi
server.disablePerMessageDeflate();

// Run the server in the background. Server can be stoped by calling server.stop()
server.start();

// Block until server.stop() is called.
server.wait();

</code></pre>
<h2 id="http-client-api">HTTP client API</h2>
<pre><code class="language-cpp">#include &lt;ixwebsocket/IXHttpClient.h&gt;

...

//
// Preparation
//
HttpClient httpClient;
HttpRequestArgsPtr args = httpClient.createRequest();

// Custom headers can be set
WebSocketHttpHeaders headers;
headers[&quot;Foo&quot;] = &quot;bar&quot;;
args-&gt;extraHeaders = headers;

// Timeout options
args-&gt;connectTimeout = connectTimeout;
args-&gt;transferTimeout = transferTimeout;

// Redirect options
args-&gt;followRedirects = followRedirects;
args-&gt;maxRedirects = maxRedirects;

// Misc
args-&gt;compress = compress; // Enable gzip compression
args-&gt;verbose = verbose;
args-&gt;logger = [](const std::string&amp; msg)
{
    std::cout &lt;&lt; msg;
};

//
// Synchronous Request
//
HttpResponsePtr out;
std::string url = &quot;https://www.google.com&quot;;

// HEAD request
out = httpClient.head(url, args);

// GET request
out = httpClient.get(url, args);

// POST request with parameters
HttpParameters httpParameters;
httpParameters[&quot;foo&quot;] = &quot;bar&quot;;

// HTTP form data can be passed in as well, for multi-part upload of files
HttpFormDataParameters httpFormDataParameters;
httpParameters[&quot;baz&quot;] = &quot;booz&quot;;

out = httpClient.post(url, httpParameters, httpFormDataParameters, args);

// POST request with a body
out = httpClient.post(url, std::string(&quot;foo=bar&quot;), args);

// PUT and PATCH are available too.

//
// Result
//
auto statusCode = response-&gt;statusCode; // Can be HttpErrorCode::Ok, HttpErrorCode::UrlMalformed, etc...
auto errorCode = response-&gt;errorCode; // 200, 404, etc...
auto responseHeaders = response-&gt;headers; // All the headers in a special case-insensitive unordered_map of (string, string)
auto body = response-&gt;body; // All the bytes from the response as an std::string
auto errorMsg = response-&gt;errorMsg; // Descriptive error message in case of failure
auto uploadSize = response-&gt;uploadSize; // Byte count of uploaded data
auto downloadSize = response-&gt;downloadSize; // Byte count of downloaded data

//
// Asynchronous Request
//
bool async = true;
HttpClient httpClient(async);
auto args = httpClient.createRequest(url, HttpClient::kGet);

// Push the request to a queue,
bool ok = httpClient.performRequest(args, [](const HttpResponsePtr&amp; response)
    {
        // This callback execute in a background thread. Make sure you uses appropriate protection such as mutex
        auto statusCode = response-&gt;statusCode; // acess results
    }
);

// ok will be false if your httpClient is not async
</code></pre>
<p>See this <a href="https://github.com/machinezone/IXWebSocket/issues/209">issue</a> for links about uploading files with HTTP multipart.</p>
<h2 id="http-server-api">HTTP server API</h2>
<pre><code class="language-cpp">#include &lt;ixwebsocket/IXHttpServer.h&gt;

ix::HttpServer server(port, hostname);

auto res = server.listen();
if (!res.first)
{
    std::cerr &lt;&lt; res.second &lt;&lt; std::endl;
    return 1;
}

server.start();
server.wait();
</code></pre>
<p>If you want to handle how requests are processed, implement the setOnConnectionCallback callback, which takes an HttpRequestPtr as input, and returns an HttpResponsePtr. You can look at HttpServer::setDefaultConnectionCallback for a slightly more advanced callback example.</p>
<pre><code class="language-cpp">setOnConnectionCallback(
    [this](HttpRequestPtr request,
           std::shared_ptr&lt;ConnectionState&gt; connectionState) -&gt; HttpResponsePtr
    {
        // Build a string for the response
        std::stringstream ss;
        ss &lt;&lt; connectionState-&gt;getRemoteIp();
           &lt;&lt; &quot; &quot;
           &lt;&lt; request-&gt;method
           &lt;&lt; &quot; &quot;
           &lt;&lt; request-&gt;uri;

        std::string content = ss.str();

        return std::make_shared&lt;HttpResponse&gt;(200, &quot;OK&quot;,
                                              HttpErrorCode::Ok,
                                              WebSocketHttpHeaders(),
                                              content);
}
</code></pre>
<h2 id="tls-support-and-configuration">TLS support and configuration</h2>
<p>To leverage TLS features, the library must be compiled with the option <code>USE_TLS=1</code>.</p>
<p>If you are using OpenSSL, try to be on a version higher than 1.1.x as there there are thread safety problems with 1.0.x.</p>
<p>Then, secure sockets are automatically used when connecting to a <code>wss://*</code> url.</p>
<p>Additional TLS options can be configured by passing a <code>ix::SocketTLSOptions</code> instance to the
<code>setTLSOptions</code> on <code>ix::WebSocket</code> (or <code>ix::WebSocketServer</code> or <code>ix::HttpServer</code>)</p>
<pre><code class="language-cpp">webSocket.setTLSOptions({
    .certFile = &quot;path/to/cert/file.pem&quot;,
    .keyFile = &quot;path/to/key/file.pem&quot;,
    .caFile = &quot;path/to/trust/bundle/file.pem&quot;, // as a file, or in memory buffer in PEM format
    .tls = true // required in server mode
});
</code></pre>
<p>Specifying <code>certFile</code> and <code>keyFile</code> configures the certificate that will be used to communicate with TLS peers.</p>
<p>On a client, this is only necessary for connecting to servers that require a client certificate.</p>
<p>On a server, this is necessary for TLS support.</p>
<p>Specifying <code>caFile</code> configures the trusted roots bundle file (in PEM format) that will be used to verify peer certificates.
 - The special value of <code>SYSTEM</code> (the default) indicates that the system-configured trust bundle should be used; this is generally what you want when connecting to any publicly exposed API/server.
 - The special value of <code>NONE</code> can be used to disable peer verification; this is only recommended to rule out certificate verification when testing connectivity.
 - If the value contain the special value <code>-----BEGIN CERTIFICATE-----</code>, the value will be read from memory, and not from a file. This is convenient on platforms like Android where reading / writing to the file system can be challenging without proper permissions, or without knowing the location of a temp directory.</p>
<p>For a client, specifying <code>caFile</code> can be used if connecting to a server that uses a self-signed cert, or when using a custom CA in an internal environment.</p>
<p>For a server, specifying <code>caFile</code> implies that:
1. You require clients to present a certificate
1. It must be signed by one of the trusted roots in the file</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js" defer></script>
        <script src="../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
