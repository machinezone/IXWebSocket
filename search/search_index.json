{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction WebSocket is a computer communications protocol, providing full-duplex and bi-directionnal communication channels over a single TCP connection. IXWebSocket is a C++ library for client and server Websocket communication, and for client and server HTTP communication. TLS aka SSL is supported. The code is derived from easywsclient and from the Satori C SDK . It has been tested on the following platforms. macOS iOS Linux Android Windows FreeBSD Example code // Required on Windows ix::initNetSystem(); // Our websocket object ix::WebSocket webSocket; std::string url(\"ws://localhost:8080/\"); webSocket.setUrl(url); // Setup a callback to be fired when a message or an event (open, close, error) is received webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr& msg) { if (msg->type == ix::WebSocketMessageType::Message) { std::cout << msg->str << std::endl; } } ); // Now that our callback is setup, we can start our background thread and receive messages webSocket.start(); // Send a message to the server (default to TEXT mode) webSocket.send(\"hello world\"); Why another library? There are 2 main reasons that explain why IXWebSocket got written. First, we needed a C++ cross-platform client library, which should have few dependencies. What looked like the most solid one, websocketpp did depend on boost and this was not an option for us. Secondly, there were other available libraries with fewer dependencies (C ones), but they required calling an explicit poll routine periodically to know if a client had received data from a server, which was not elegant. We started by solving those 2 problems, then we added server websocket code, then an HTTP client, and finally a very simple HTTP server. IXWebSocket comes with a command line utility named ws which is quite handy, and is now packaged with alpine linux. You can install it with apk add ws . Few dependencies (only zlib) Simple to use ; uses std::string and std::function callbacks. Complete support of the websocket protocol, and basic http support. Client and Server TLS support Alternative libraries There are plenty of great websocket libraries out there, which might work for you. Here are a couple of serious ones. websocketpp - C++ beast - C++ libwebsockets - C \u00b5WebSockets - C Contributing IXWebSocket is developed on GitHub . We'd love to hear about how you use it; opening up an issue on GitHub is ok for that. If things don't work as expected, please create an issue on GitHub, or even better a pull request if you know how to fix your problem.","title":"Home"},{"location":"#introduction","text":"WebSocket is a computer communications protocol, providing full-duplex and bi-directionnal communication channels over a single TCP connection. IXWebSocket is a C++ library for client and server Websocket communication, and for client and server HTTP communication. TLS aka SSL is supported. The code is derived from easywsclient and from the Satori C SDK . It has been tested on the following platforms. macOS iOS Linux Android Windows FreeBSD","title":"Introduction"},{"location":"#example-code","text":"// Required on Windows ix::initNetSystem(); // Our websocket object ix::WebSocket webSocket; std::string url(\"ws://localhost:8080/\"); webSocket.setUrl(url); // Setup a callback to be fired when a message or an event (open, close, error) is received webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr& msg) { if (msg->type == ix::WebSocketMessageType::Message) { std::cout << msg->str << std::endl; } } ); // Now that our callback is setup, we can start our background thread and receive messages webSocket.start(); // Send a message to the server (default to TEXT mode) webSocket.send(\"hello world\");","title":"Example code"},{"location":"#why-another-library","text":"There are 2 main reasons that explain why IXWebSocket got written. First, we needed a C++ cross-platform client library, which should have few dependencies. What looked like the most solid one, websocketpp did depend on boost and this was not an option for us. Secondly, there were other available libraries with fewer dependencies (C ones), but they required calling an explicit poll routine periodically to know if a client had received data from a server, which was not elegant. We started by solving those 2 problems, then we added server websocket code, then an HTTP client, and finally a very simple HTTP server. IXWebSocket comes with a command line utility named ws which is quite handy, and is now packaged with alpine linux. You can install it with apk add ws . Few dependencies (only zlib) Simple to use ; uses std::string and std::function callbacks. Complete support of the websocket protocol, and basic http support. Client and Server TLS support","title":"Why another library?"},{"location":"#alternative-libraries","text":"There are plenty of great websocket libraries out there, which might work for you. Here are a couple of serious ones. websocketpp - C++ beast - C++ libwebsockets - C \u00b5WebSockets - C","title":"Alternative libraries"},{"location":"#contributing","text":"IXWebSocket is developed on GitHub . We'd love to hear about how you use it; opening up an issue on GitHub is ok for that. If things don't work as expected, please create an issue on GitHub, or even better a pull request if you know how to fix your problem.","title":"Contributing"},{"location":"CHANGELOG/","text":"Changelog All changes to this project will be documented in this file. [9.2.2] - 2020-04-04 (third_party deps) fix #177, update bundled spdlog to 1.6.0 [9.2.1] - 2020-04-04 (windows) when using OpenSSL, the system store is used to populate the cacert. No need to ship a cacert.pem file with your app. [9.2.0] - 2020-04-04 (windows) ci: windows build with TLS (mbedtls) + verify that we can be build with OpenSSL [9.1.9] - 2020-03-30 (cobra to statsd bot) add ability to extract a numerical value and send a timer event to statsd, with the --timer option [9.1.8] - 2020-03-29 (cobra to statsd bot) bot init was missing + capture socket error [9.1.7] - 2020-03-29 (cobra to statsd bot) add ability to extract a numerical value and send a gauge event to statsd, with the --gauge option [9.1.6] - 2020-03-29 (ws cobra subscriber) use a Json::StreamWriter to write to std::cout, and save one std::string allocation for each message printed [9.1.5] - 2020-03-29 (docker) trim down docker image (300M -> 12M) / binary built without symbol and size optimization, and source code not copied over [9.1.4] - 2020-03-28 (jsoncpp) update bundled copy to version 1.9.3 (at sha 3beb37ea14aec1bdce1a6d542dc464d00f4a6cec) [9.1.3] - 2020-03-27 (docker) alpine docker build with release with debug info, and bundle ca-certificates [9.1.2] - 2020-03-26 (mac ssl) rename DarwinSSL -> SecureTransport (see this too -> https://github.com/curl/curl/issues/3733) [9.1.1] - 2020-03-26 (websocket) fix data race accessing _socket object without mutex protection when calling wakeUpFromPoll in WebSocketTransport.cpp [9.1.0] - 2020-03-26 (ixcobra) add explicit event types for handshake, authentication and subscription failure, and handle those by exiting in ws_cobra_subcribe and friends [9.0.3] - 2020-03-24 (ws connect) display statistics about how much time it takes to stop the connection [9.0.2] - 2020-03-24 (socket) works with unique_ptr instead of shared_ptr in many places [9.0.1] - 2020-03-24 (socket) selectInterrupt member is an unique_ptr instead of being a shared_ptr [9.0.0] - 2020-03-23 (websocket) reset per-message deflate codec everytime we connect to a server/client [8.3.4] - 2020-03-23 (websocket) fix #167, a long standing issue with sending empty messages with per-message deflate extension (and hopefully other zlib bug) [8.3.3] - 2020-03-22 (cobra to statsd) port to windows and add a unittest [8.3.2] - 2020-03-20 (websocket+tls) fix hang in tls handshake which could lead to ANR, discovered through unittesting. [8.3.1] - 2020-03-20 (cobra) CobraMetricsPublisher can be configure with an ix::CobraConfig + more unittest use SSL in server + client [8.3.0] - 2020-03-18 (websocket) Simplify ping/pong based heartbeat implementation [8.2.7] - 2020-03-17 (ws) ws connect gains a new option to set the interval at which to send pings (ws) ws echo_server gains a new option (-p) to disable responding to pings with pongs IXWebSocket$ ws connect --ping_interval 2 wss://echo.websocket.org Type Ctrl-D to exit prompt... Connecting to url: wss://echo.websocket.org > ws_connect: connected [2020-03-17 23:53:02.726] [info] Uri: / [2020-03-17 23:53:02.726] [info] Headers: [2020-03-17 23:53:02.727] [info] Connection: Upgrade [2020-03-17 23:53:02.727] [info] Date: Wed, 18 Mar 2020 06:45:05 GMT [2020-03-17 23:53:02.727] [info] Sec-WebSocket-Accept: 0gtqbxW0aVL/QI/ICpLFnRaiKgA= [2020-03-17 23:53:02.727] [info] sec-websocket-extensions: [2020-03-17 23:53:02.727] [info] Server: Kaazing Gateway [2020-03-17 23:53:02.727] [info] Upgrade: websocket [2020-03-17 23:53:04.894] [info] Received pong [2020-03-17 23:53:06.859] [info] Received pong [2020-03-17 23:53:08.881] [info] Received pong [2020-03-17 23:53:10.848] [info] Received pong [2020-03-17 23:53:12.898] [info] Received pong [2020-03-17 23:53:14.865] [info] Received pong [2020-03-17 23:53:16.890] [info] Received pong [2020-03-17 23:53:18.853] [info] Received pong [2020-03-17 23:53:19.388] [info] ws_connect: connection closed: code 1000 reason Normal closure [2020-03-17 23:53:19.502] [info] Received 208 bytes [2020-03-17 23:53:19.502] [info] Sent 0 bytes [8.2.6] - 2020-03-16 (cobra to sentry bot + docker) default docker file uses mbedtls + ws cobra_to_sentry pass tls options to sentryClient. [8.2.5] - 2020-03-13 (cobra client) ws cobra subscribe resubscribe at latest position after being disconnected [8.2.4] - 2020-03-13 (cobra client) can subscribe with a position [8.2.3] - 2020-03-13 (cobra client) pass the message position to the subscription data callback [8.2.2] - 2020-03-12 (openssl tls backend) Fix a hand in OpenSSL when using TLS v1.3 ... by disabling TLS v1.3 [8.2.1] - 2020-03-11 (cobra) IXCobraConfig struct has tlsOptions and per message deflate options [8.2.0] - 2020-03-11 (cobra) add IXCobraConfig struct to pass cobra config around [8.1.9] - 2020-03-09 (ws cobra_subscribe) add a --fluentd option to wrap a message in an enveloppe so that fluentd can recognize it [8.1.8] - 2020-03-02 (websocket server) fix regression with disabling zlib extension on the server side. If a client does not support this extension the server will handle it fine. We still need to figure out how to disable the option. [8.1.7] - 2020-02-26 (websocket) traffic tracker received bytes is message size while it should be wire size [8.1.6] - 2020-02-26 (ws_connect) display sent/received bytes statistics on exit [8.1.5] - 2020-02-23 (server) give thread name to some usual worker threads / unittest is broken !! [8.1.4] - 2020-02-22 (websocket server) fix regression from 8.1.2, where per-deflate message compression was always disabled [8.1.3] - 2020-02-21 (client + server) Fix #155 / http header parser should treat the space(s) after the : delimiter as optional. Fixing this bug made us discover that websocket sub-protocols are not properly serialiazed, but start with a , [8.1.2] - 2020-02-18 (WebSocketServer) add option to disable deflate compression, exposed with the -x option to ws echo_server [8.1.1] - 2020-02-18 (ws cobra to statsd and sentry sender) exit if no messages are received for one minute, which is a sign that something goes wrong on the server side. That should be changed to be configurable in the future [8.1.0] - 2020-02-13 (http client + sentry minidump upload) Multipart stream closing boundary is invalid + mark some options as mandatory in the command line tools [8.0.7] - 2020-02-12 (build) remove the unused subtree which was causing some way of installing to break [8.0.6] - 2020-01-31 (snake) add an option to disable answering pongs as response to pings, to test cobra client behavior with hanged connections [8.0.5] - 2020-01-31 (IXCobraConnection) set a ping timeout of 90 seconds. If no pong messages are received as responses to ping for a while, give up and close the connection [8.0.4] - 2020-01-31 (cobra to sentry) remove noisy logging [8.0.3] - 2020-01-30 (ixcobra) check if we are authenticated in publishNext before trying to publish a message [8.0.2] - 2020-01-28 Extract severity level when emitting messages to sentry [8.0.1] - 2020-01-28 Fix bug #151 - If a socket connection is interrupted, calling stop() on the IXWebSocket object blocks until the next retry [8.0.0] - 2020-01-26 (SocketServer) add ability to bind on an ipv6 address [7.9.6] - 2020-01-22 (ws) add a dnslookup sub-command, to get the ip address of a remote host [7.9.5] - 2020-01-14 (windows) fix #144, get rid of stubbed/un-implemented windows schannel ssl backend [7.9.4] - 2020-01-12 (openssl + mbedssl) fix #140, can send large files with ws send over ssl / still broken with apple ssl [7.9.3] - 2020-01-10 (apple ssl) model write method after the OpenSSL one for consistency [7.9.2] - 2020-01-06 (apple ssl) unify read and write ssl utility code [7.9.1] - 2020-01-06 (websocket client) better error propagation when errors are detected while sending data (ws send) detect failures to send big files, terminate in those cases and report error [7.9.0] - 2020-01-04 (ws send) add option (-x) to disable per message deflate compression [7.8.9] - 2020-01-04 (ws send + receive) handle all message types (ping + pong + fragment) / investigate #140 [7.8.8] - 2019-12-28 (mbedtls) fix related to private key file parsing and initialization [7.8.6] - 2019-12-28 (ws cobra to sentry/statsd) fix for handling null events properly for empty queues + use queue to send data to statsd [7.8.5] - 2019-12-28 (ws cobra to sentry) handle null events for empty queues [7.8.4] - 2019-12-27 (ws cobra to sentry) game is picked in a fair manner, so that all games get the same share of sent events [7.8.3] - 2019-12-27 (ws cobra to sentry) refactor queue related code into a class [7.8.2] - 2019-12-25 (ws cobra to sentry) bound the queue size used to hold up cobra messages before they are sent to sentry. Default queue size is a 100 messages. Without such limit the program runs out of memory when a subscriber receive a lot of messages that cannot make it to sentry [7.8.1] - 2019-12-25 (ws client) use correct compilation defines so that spdlog is not used as a header only library (reduce binary size and increase compilation speed) [7.8.0] - 2019-12-24 (ws client) all commands use spdlog instead of std::cerr or std::cout for logging [7.6.5] - 2019-12-24 (cobra client) send a websocket ping every 30s to keep the connection opened [7.6.4] - 2019-12-22 (client) error handling, quote url in error case when failing to parse one (ws) ws_cobra_publish: register callbacks before connecting (doc) mention mbedtls in supported ssl server backend [7.6.3] - 2019-12-20 (tls) add a simple description of the TLS configuration routine for debugging [7.6.2] - 2019-12-20 (mbedtls) correct support for using own certificate and private key [7.6.1] - 2019-12-20 (ws commands) in websocket proxy, disable automatic reconnections + in Dockerfile, use alpine 3.11 [7.6.0] - 2019-12-19 (cobra) Add TLS options to all cobra commands and classes. Add example to the doc. [7.5.8] - 2019-12-18 (cobra-to-sentry) capture application version from device field [7.5.7] - 2019-12-18 (tls) Experimental TLS server support with mbedtls (windows) + process cert tlsoption (client + server) [7.5.6] - 2019-12-18 (tls servers) Make it clear that apple ssl and mbedtls backends do not support SSL in server mode [7.5.5] - 2019-12-17 (tls options client) TLSOptions struct _validated member should be initialized to false [7.5.4] - 2019-12-16 (websocket client) improve the error message when connecting to a non websocket server Before: Connection error: Got bad status connecting to example.com:443, status: 200, HTTP Status line: HTTP/1.1 200 OK After: Connection error: Expecting status 101 (Switching Protocol), got 200 status connecting to example.com:443, HTTP Status line: HTTP/1.1 200 OK [7.5.3] - 2019-12-12 (server) attempt at fixing #131 by using blocking writes in server mode [7.5.2] - 2019-12-11 (ws) cobra to sentry - created events with sentry tags based on tags present in the cobra messages [7.5.1] - 2019-12-06 (mac) convert SSL errors to utf8 [7.5.0] - 2019-12-05 (ws) cobra to sentry. Handle Error 429 Too Many Requests and politely wait before sending more data to sentry. In the example below sentry we are sending data too fast, sentry asks us to slow down which we do. Notice how the sent count stop increasing, while we are waiting for 41 seconds. [2019-12-05 15:50:33.759] [info] messages received 2449 sent 3 [2019-12-05 15:50:34.759] [info] messages received 5533 sent 7 [2019-12-05 15:50:35.759] [info] messages received 8612 sent 11 [2019-12-05 15:50:36.759] [info] messages received 11562 sent 15 [2019-12-05 15:50:37.759] [info] messages received 14410 sent 19 [2019-12-05 15:50:38.759] [info] messages received 17236 sent 23 [2019-12-05 15:50:39.282] [error] Error sending data to sentry: 429 [2019-12-05 15:50:39.282] [error] Body: {\"exception\":[{\"stacktrace\":{\"frames\":[{\"filename\":\"WorldScene.lua\",\"function\":\"WorldScene.lua:1935\",\"lineno\":1958},{\"filename\":\"WorldScene.lua\",\"function\":\"onUpdate_WorldCam\",\"lineno\":1921},{\"filename\":\"WorldMapTile.lua\",\"function\":\"__index\",\"lineno\":239}]},\"value\":\"noisytypes: Attempt to call nil(nil,2224139838)!\"}],\"platform\":\"python\",\"sdk\":{\"name\":\"ws\",\"version\":\"1.0.0\"},\"tags\":[[\"game\",\"niso\"],[\"userid\",\"107638363\"],[\"environment\",\"live\"]],\"timestamp\":\"2019-12-05T23:50:39Z\"} [2019-12-05 15:50:39.282] [error] Response: {\"error_name\":\"rate_limit\",\"error\":\"Creation of this event was denied due to rate limiting\"} [2019-12-05 15:50:39.282] [warning] Error 429 - Too Many Requests. ws will sleep and retry after 41 seconds [2019-12-05 15:50:39.760] [info] messages received 18839 sent 25 [2019-12-05 15:50:40.760] [info] messages received 18839 sent 25 [2019-12-05 15:50:41.760] [info] messages received 18839 sent 25 [2019-12-05 15:50:42.761] [info] messages received 18839 sent 25 [2019-12-05 15:50:43.762] [info] messages received 18839 sent 25 [2019-12-05 15:50:44.763] [info] messages received 18839 sent 25 [2019-12-05 15:50:45.768] [info] messages received 18839 sent 25 [7.4.5] - 2019-12-03 (ws) #125 / fix build problem when jsoncpp is not installed locally [7.4.4] - 2019-12-03 (ws) #125 / cmake detects an already installed jsoncpp and will try to use this one if present [7.4.3] - 2019-12-03 (http client) use std::unordered_map instead of std::map for HttpParameters and HttpFormDataParameters class aliases [7.4.2] - 2019-12-02 (client) internal IXDNSLookup class requires a valid cancellation request function callback to be passed in [7.4.1] - 2019-12-02 (client) fix an overflow in the exponential back off code [7.4.0] - 2019-11-25 (http client) Add support for multipart HTTP POST upload (ixsentry) Add support for uploading a minidump to sentry [7.3.5] - 2019-11-20 On Darwin SSL, add ability to skip peer verification. [7.3.4] - 2019-11-20 32-bits compile fix, courtesy of @fcojavmc [7.3.1] - 2019-11-16 ws proxy_server / remote server close not forwarded to the client [7.3.0] - 2019-11-15 New ws command: ws proxy_server . [7.2.2] - 2019-11-01 Tag a release + minor reformating. [7.2.1] - 2019-10-26 Add unittest to IXSentryClient to lua backtrace parsing code [7.2.0] - 2019-10-24 Add cobra_metrics_to_redis sub-command to create streams for each cobra metric event being received. [7.1.0] - 2019-10-13 Add client support for websocket subprotocol. Look for the new addSubProtocol method for details. [7.0.0] - 2019-10-01 TLS support in server code, only implemented for the OpenSSL SSL backend for now. [6.3.4] - 2019-09-30 all ws subcommands propagate tls options to servers (unimplemented) or ws or http client (implemented) (contributed by Matt DeBoer) [6.3.3] - 2019-09-30 ws has a --version option [6.3.2] - 2019-09-29 (http + websocket clients) can specify cacert and some other tls options (not implemented on all backend). This makes it so that server certs can finally be validated on windows. [6.3.1] - 2019-09-29 Add ability to use OpenSSL on apple platforms. [6.3.0] - 2019-09-28 ixcobra / fix crash in CobraConnection::publishNext when the queue is empty + handle CobraConnection_PublishMode_Batch in CobraMetricsThreadedPublisher [6.2.9] - 2019-09-27 mbedtls fixes / the unittest now pass on macOS, and hopefully will on Windows/AppVeyor as well. [6.2.8] - 2019-09-26 Http server: add options to ws https to redirect all requests to a given url. POST requests will get a 200 and an empty response. ws httpd -L --redirect_url https://www.google.com [6.2.7] - 2019-09-25 Stop having ws send subcommand send a binary message in text mode, which would cause error in make ws_test shell script test. [6.2.6] - 2019-09-24 Fix 2 race conditions detected with TSan, one in CobraMetricsPublisher::push and another one in WebSocketTransport::sendData (that one was bad). [6.2.5] - 2019-09-23 Add simple Redis Server which is only capable of doing publish / subscribe. New ws redis_server sub-command to use it. The server is used in the unittest, so that we can run on CI in environment where redis isn not available like github actions env. [6.2.4] - 2019-09-22 Add options to configure TLS ; contributed by Matt DeBoer. Only implemented for OpenSSL TLS backend for now. [6.2.3] - 2019-09-21 Fix crash in the Linux unittest in the HTTP client code, in Socket::readBytes Cobra Metrics Publisher code returns the message id of the message that got published, to be used to validated that it got sent properly when receiving an ack. [6.2.2] - 2019-09-19 In DNS lookup code, make sure the weak pointer we use lives through the expected scope (if branch) [6.2.1] - 2019-09-17 On error while doing a client handshake, additionally display port number next to the host name [6.2.0] - 2019-09-09 websocket and http server: server does not close the bound client socket in many cases improve some websocket error messages add a utility function with unittest to parse status line and stop using scanf which triggers warnings on Windows update ws CLI11 (our command line argument parsing library) to the latest, which fix a compiler bug about optional [6.1.0] - 2019-09-08 move poll wrapper on top of select (only used on Windows) to the ix namespace [6.0.1] - 2019-09-05 add cobra metrics publisher + server unittest add cobra client + server unittest ws snake (cobra simple server) add basic support for unsubscription + subscribe send the proper subscription data + redis client subscription can be cancelled IXCobraConnection / pdu handlers can crash if they receive json data which is not an object [6.0.0] - 2019-09-04 all client autobahn test should pass ! zlib/deflate has a bug with windowsbits == 8, so we silently upgrade it to 9/ (fix autobahn test 13.X which uses 8 for the windows size) [5.2.0] - 2019-09-04 Fragmentation: for sent messages which are compressed, the continuation fragments should not have the rsv1 bit set (fix all autobahn tests for zlib compression 12.X) Websocket Server / do a case insensitive string search when looking for an Upgrade header whose value is websocket. (some client use WebSocket with some upper-case characters) [5.1.9] - 2019-09-03 ws autobahn / report progress with spdlog::info to get timing info ws autobahn / use condition variables for stopping test case + add more logging on errors [5.1.8] - 2019-09-03 Per message deflate/compression: handle fragmented messages (fix autobahn test: 12.1.X and probably others) [5.1.7] - 2019-09-03 Receiving invalid UTF-8 TEXT message should fail and close the connection (fix remaining autobahn test: 6.X UTF-8 Handling) [5.1.6] - 2019-09-03 Sending invalid UTF-8 TEXT message should fail and close the connection (fix remaining autobahn test: 6.X UTF-8 Handling) Fix failing unittest which was sending binary data in text mode with WebSocket::send to call properly call WebSocket::sendBinary instead. Validate that the reason is proper utf-8. (fix autobahn test 7.5.1) Validate close codes. Autobahn 7.9.* [5.1.5] - 2019-09-03 Framentation: data and continuation blocks received out of order (fix autobahn test: 5.9 through 5.20 Fragmentation) [5.1.4] - 2019-09-03 Sending invalid UTF-8 TEXT message should fail and close the connection (fix tons of autobahn test: 6.X UTF-8 Handling) [5.1.3] - 2019-09-03 Message type (TEXT or BINARY) is invalid for received fragmented messages (fix autobahn test: 5.3 through 5.8 Fragmentation) [5.1.2] - 2019-09-02 Ping and Pong messages cannot be fragmented (fix autobahn test: 5.1 and 5.2 Fragmentation) [5.1.1] - 2019-09-01 Close connections when reserved bits are used (fix autobahn test: 3.X Reserved Bits) [5.1.0] - 2019-08-31 ws autobahn / Add code to test websocket client compliance with the autobahn test-suite add utf-8 validation code, not hooked up properly yet Ping received with a payload too large (> 125 bytes) trigger a connection closure cobra / add tracking about published messages cobra / publish returns a message id, that can be used when cobra / new message type in the message received handler when publish/ok is received (can be used to implement an ack system). [5.0.9] - 2019-08-30 User-Agent header is set when not specified. New option to cap the max wait between reconnection attempts. Still default to 10s. (setMaxWaitBetweenReconnectionRetries). ws connect --max_wait 5000 ws://example.com # will only wait 5 seconds max between reconnection attempts [5.0.7] - 2019-08-23 WebSocket: add new option to pass in extra HTTP headers when connecting. ws connect add new option (-H, works like curl ) to pass in extra HTTP headers when connecting If you run against ws echo_server you will see the headers being received printed in the terminal. ws connect -H \"foo: bar\" -H \"baz: buz\" ws://127.0.0.1:8008 CobraConnection: sets a unique id field for all messages sent to cobra . CobraConnection: sets a counter as a field for each event published. [5.0.6] - 2019-08-22 Windows: silly compile error (poll should be in the global namespace) [5.0.5] - 2019-08-22 Windows: use select instead of WSAPoll, through a poll wrapper [5.0.4] - 2019-08-20 Windows build fixes (there was a problem with the use of ::poll that has a different name on Windows (WSAPoll)) [5.0.3] - 2019-08-14 CobraMetricThreadedPublisher _enable flag is an atomic, and CobraMetricsPublisher is enabled by default [5.0.2] - 2019-08-01 ws cobra_subscribe has a new -q (quiet) option ws cobra_subscribe knows to and display msg stats (count and # of messages received per second) ws cobra_subscribe, cobra_to_statsd and cobra_to_sentry commands have a new option, --filter to restrict the events they want to receive [5.0.1] - 2019-07-25 ws connect command has a new option to send in binary mode (still default to text) ws connect command has readline history thanks to libnoise-cpp. Now ws connect one can use using arrows to lookup previous sent messages and edit them [5.0.0] - 2019-06-23 Changed New HTTP server / still very early. ws gained a new command, httpd can run a simple webserver serving local files. IXDNSLookup. Uses weak pointer + smart_ptr + shared_from_this instead of static sets + mutex to handle object going away before dns lookup has resolved cobra_to_sentry / backtraces are reversed and line number is not extracted correctly mbedtls and zlib are searched with find_package, and we use the vendored version if nothing is found travis CI uses g++ on Linux [4.0.0] - 2019-06-09 Changed WebSocket::send() sends message in TEXT mode by default WebSocketMessage sets a new binary field, which tells whether the received incoming message is binary or text WebSocket::send takes a third arg, binary which default to true (can be text too) WebSocket callback only take one object, a const ix::WebSocketMessagePtr& msg Add explicit WebSocket::sendBinary method New headers + WebSocketMessage class to hold message data, still not used across the board Add test/compatibility folder with small servers and clients written in different languages and different libraries to test compatibility. ws echo_server has a -g option to print a greeting message on connect IXSocketMbedTLS: better error handling in close and connect [3.1.2] - 2019-06-06 Added ws connect has a -x option to disable per message deflate Add WebSocket::disablePerMessageDeflate() option. [3.0.0] - 2019-06-xx Changed TLS, aka SSL works on Windows (websocket and http clients) ws command line tool build on Windows Async API for HttpClient HttpClient API changed to use shared_ptr for response and request","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"All changes to this project will be documented in this file.","title":"Changelog"},{"location":"CHANGELOG/#922-2020-04-04","text":"(third_party deps) fix #177, update bundled spdlog to 1.6.0","title":"[9.2.2] - 2020-04-04"},{"location":"CHANGELOG/#921-2020-04-04","text":"(windows) when using OpenSSL, the system store is used to populate the cacert. No need to ship a cacert.pem file with your app.","title":"[9.2.1] - 2020-04-04"},{"location":"CHANGELOG/#920-2020-04-04","text":"(windows) ci: windows build with TLS (mbedtls) + verify that we can be build with OpenSSL","title":"[9.2.0] - 2020-04-04"},{"location":"CHANGELOG/#919-2020-03-30","text":"(cobra to statsd bot) add ability to extract a numerical value and send a timer event to statsd, with the --timer option","title":"[9.1.9] - 2020-03-30"},{"location":"CHANGELOG/#918-2020-03-29","text":"(cobra to statsd bot) bot init was missing + capture socket error","title":"[9.1.8] - 2020-03-29"},{"location":"CHANGELOG/#917-2020-03-29","text":"(cobra to statsd bot) add ability to extract a numerical value and send a gauge event to statsd, with the --gauge option","title":"[9.1.7] - 2020-03-29"},{"location":"CHANGELOG/#916-2020-03-29","text":"(ws cobra subscriber) use a Json::StreamWriter to write to std::cout, and save one std::string allocation for each message printed","title":"[9.1.6] - 2020-03-29"},{"location":"CHANGELOG/#915-2020-03-29","text":"(docker) trim down docker image (300M -> 12M) / binary built without symbol and size optimization, and source code not copied over","title":"[9.1.5] - 2020-03-29"},{"location":"CHANGELOG/#914-2020-03-28","text":"(jsoncpp) update bundled copy to version 1.9.3 (at sha 3beb37ea14aec1bdce1a6d542dc464d00f4a6cec)","title":"[9.1.4] - 2020-03-28"},{"location":"CHANGELOG/#913-2020-03-27","text":"(docker) alpine docker build with release with debug info, and bundle ca-certificates","title":"[9.1.3] - 2020-03-27"},{"location":"CHANGELOG/#912-2020-03-26","text":"(mac ssl) rename DarwinSSL -> SecureTransport (see this too -> https://github.com/curl/curl/issues/3733)","title":"[9.1.2] - 2020-03-26"},{"location":"CHANGELOG/#911-2020-03-26","text":"(websocket) fix data race accessing _socket object without mutex protection when calling wakeUpFromPoll in WebSocketTransport.cpp","title":"[9.1.1] - 2020-03-26"},{"location":"CHANGELOG/#910-2020-03-26","text":"(ixcobra) add explicit event types for handshake, authentication and subscription failure, and handle those by exiting in ws_cobra_subcribe and friends","title":"[9.1.0] - 2020-03-26"},{"location":"CHANGELOG/#903-2020-03-24","text":"(ws connect) display statistics about how much time it takes to stop the connection","title":"[9.0.3] - 2020-03-24"},{"location":"CHANGELOG/#902-2020-03-24","text":"(socket) works with unique_ptr instead of shared_ptr in many places","title":"[9.0.2] - 2020-03-24"},{"location":"CHANGELOG/#901-2020-03-24","text":"(socket) selectInterrupt member is an unique_ptr instead of being a shared_ptr","title":"[9.0.1] - 2020-03-24"},{"location":"CHANGELOG/#900-2020-03-23","text":"(websocket) reset per-message deflate codec everytime we connect to a server/client","title":"[9.0.0] - 2020-03-23"},{"location":"CHANGELOG/#834-2020-03-23","text":"(websocket) fix #167, a long standing issue with sending empty messages with per-message deflate extension (and hopefully other zlib bug)","title":"[8.3.4] - 2020-03-23"},{"location":"CHANGELOG/#833-2020-03-22","text":"(cobra to statsd) port to windows and add a unittest","title":"[8.3.3] - 2020-03-22"},{"location":"CHANGELOG/#832-2020-03-20","text":"(websocket+tls) fix hang in tls handshake which could lead to ANR, discovered through unittesting.","title":"[8.3.2] - 2020-03-20"},{"location":"CHANGELOG/#831-2020-03-20","text":"(cobra) CobraMetricsPublisher can be configure with an ix::CobraConfig + more unittest use SSL in server + client","title":"[8.3.1] - 2020-03-20"},{"location":"CHANGELOG/#830-2020-03-18","text":"(websocket) Simplify ping/pong based heartbeat implementation","title":"[8.3.0] - 2020-03-18"},{"location":"CHANGELOG/#827-2020-03-17","text":"(ws) ws connect gains a new option to set the interval at which to send pings (ws) ws echo_server gains a new option (-p) to disable responding to pings with pongs IXWebSocket$ ws connect --ping_interval 2 wss://echo.websocket.org Type Ctrl-D to exit prompt... Connecting to url: wss://echo.websocket.org > ws_connect: connected [2020-03-17 23:53:02.726] [info] Uri: / [2020-03-17 23:53:02.726] [info] Headers: [2020-03-17 23:53:02.727] [info] Connection: Upgrade [2020-03-17 23:53:02.727] [info] Date: Wed, 18 Mar 2020 06:45:05 GMT [2020-03-17 23:53:02.727] [info] Sec-WebSocket-Accept: 0gtqbxW0aVL/QI/ICpLFnRaiKgA= [2020-03-17 23:53:02.727] [info] sec-websocket-extensions: [2020-03-17 23:53:02.727] [info] Server: Kaazing Gateway [2020-03-17 23:53:02.727] [info] Upgrade: websocket [2020-03-17 23:53:04.894] [info] Received pong [2020-03-17 23:53:06.859] [info] Received pong [2020-03-17 23:53:08.881] [info] Received pong [2020-03-17 23:53:10.848] [info] Received pong [2020-03-17 23:53:12.898] [info] Received pong [2020-03-17 23:53:14.865] [info] Received pong [2020-03-17 23:53:16.890] [info] Received pong [2020-03-17 23:53:18.853] [info] Received pong [2020-03-17 23:53:19.388] [info] ws_connect: connection closed: code 1000 reason Normal closure [2020-03-17 23:53:19.502] [info] Received 208 bytes [2020-03-17 23:53:19.502] [info] Sent 0 bytes","title":"[8.2.7] - 2020-03-17"},{"location":"CHANGELOG/#826-2020-03-16","text":"(cobra to sentry bot + docker) default docker file uses mbedtls + ws cobra_to_sentry pass tls options to sentryClient.","title":"[8.2.6] - 2020-03-16"},{"location":"CHANGELOG/#825-2020-03-13","text":"(cobra client) ws cobra subscribe resubscribe at latest position after being disconnected","title":"[8.2.5] - 2020-03-13"},{"location":"CHANGELOG/#824-2020-03-13","text":"(cobra client) can subscribe with a position","title":"[8.2.4] - 2020-03-13"},{"location":"CHANGELOG/#823-2020-03-13","text":"(cobra client) pass the message position to the subscription data callback","title":"[8.2.3] - 2020-03-13"},{"location":"CHANGELOG/#822-2020-03-12","text":"(openssl tls backend) Fix a hand in OpenSSL when using TLS v1.3 ... by disabling TLS v1.3","title":"[8.2.2] - 2020-03-12"},{"location":"CHANGELOG/#821-2020-03-11","text":"(cobra) IXCobraConfig struct has tlsOptions and per message deflate options","title":"[8.2.1] - 2020-03-11"},{"location":"CHANGELOG/#820-2020-03-11","text":"(cobra) add IXCobraConfig struct to pass cobra config around","title":"[8.2.0] - 2020-03-11"},{"location":"CHANGELOG/#819-2020-03-09","text":"(ws cobra_subscribe) add a --fluentd option to wrap a message in an enveloppe so that fluentd can recognize it","title":"[8.1.9] - 2020-03-09"},{"location":"CHANGELOG/#818-2020-03-02","text":"(websocket server) fix regression with disabling zlib extension on the server side. If a client does not support this extension the server will handle it fine. We still need to figure out how to disable the option.","title":"[8.1.8] - 2020-03-02"},{"location":"CHANGELOG/#817-2020-02-26","text":"(websocket) traffic tracker received bytes is message size while it should be wire size","title":"[8.1.7] - 2020-02-26"},{"location":"CHANGELOG/#816-2020-02-26","text":"(ws_connect) display sent/received bytes statistics on exit","title":"[8.1.6] - 2020-02-26"},{"location":"CHANGELOG/#815-2020-02-23","text":"(server) give thread name to some usual worker threads / unittest is broken !!","title":"[8.1.5] - 2020-02-23"},{"location":"CHANGELOG/#814-2020-02-22","text":"(websocket server) fix regression from 8.1.2, where per-deflate message compression was always disabled","title":"[8.1.4] - 2020-02-22"},{"location":"CHANGELOG/#813-2020-02-21","text":"(client + server) Fix #155 / http header parser should treat the space(s) after the : delimiter as optional. Fixing this bug made us discover that websocket sub-protocols are not properly serialiazed, but start with a ,","title":"[8.1.3] - 2020-02-21"},{"location":"CHANGELOG/#812-2020-02-18","text":"(WebSocketServer) add option to disable deflate compression, exposed with the -x option to ws echo_server","title":"[8.1.2] - 2020-02-18"},{"location":"CHANGELOG/#811-2020-02-18","text":"(ws cobra to statsd and sentry sender) exit if no messages are received for one minute, which is a sign that something goes wrong on the server side. That should be changed to be configurable in the future","title":"[8.1.1] - 2020-02-18"},{"location":"CHANGELOG/#810-2020-02-13","text":"(http client + sentry minidump upload) Multipart stream closing boundary is invalid + mark some options as mandatory in the command line tools","title":"[8.1.0] - 2020-02-13"},{"location":"CHANGELOG/#807-2020-02-12","text":"(build) remove the unused subtree which was causing some way of installing to break","title":"[8.0.7] - 2020-02-12"},{"location":"CHANGELOG/#806-2020-01-31","text":"(snake) add an option to disable answering pongs as response to pings, to test cobra client behavior with hanged connections","title":"[8.0.6] - 2020-01-31"},{"location":"CHANGELOG/#805-2020-01-31","text":"(IXCobraConnection) set a ping timeout of 90 seconds. If no pong messages are received as responses to ping for a while, give up and close the connection","title":"[8.0.5] - 2020-01-31"},{"location":"CHANGELOG/#804-2020-01-31","text":"(cobra to sentry) remove noisy logging","title":"[8.0.4] - 2020-01-31"},{"location":"CHANGELOG/#803-2020-01-30","text":"(ixcobra) check if we are authenticated in publishNext before trying to publish a message","title":"[8.0.3] - 2020-01-30"},{"location":"CHANGELOG/#802-2020-01-28","text":"Extract severity level when emitting messages to sentry","title":"[8.0.2] - 2020-01-28"},{"location":"CHANGELOG/#801-2020-01-28","text":"Fix bug #151 - If a socket connection is interrupted, calling stop() on the IXWebSocket object blocks until the next retry","title":"[8.0.1] - 2020-01-28"},{"location":"CHANGELOG/#800-2020-01-26","text":"(SocketServer) add ability to bind on an ipv6 address","title":"[8.0.0] - 2020-01-26"},{"location":"CHANGELOG/#796-2020-01-22","text":"(ws) add a dnslookup sub-command, to get the ip address of a remote host","title":"[7.9.6] - 2020-01-22"},{"location":"CHANGELOG/#795-2020-01-14","text":"(windows) fix #144, get rid of stubbed/un-implemented windows schannel ssl backend","title":"[7.9.5] - 2020-01-14"},{"location":"CHANGELOG/#794-2020-01-12","text":"(openssl + mbedssl) fix #140, can send large files with ws send over ssl / still broken with apple ssl","title":"[7.9.4] - 2020-01-12"},{"location":"CHANGELOG/#793-2020-01-10","text":"(apple ssl) model write method after the OpenSSL one for consistency","title":"[7.9.3] - 2020-01-10"},{"location":"CHANGELOG/#792-2020-01-06","text":"(apple ssl) unify read and write ssl utility code","title":"[7.9.2] - 2020-01-06"},{"location":"CHANGELOG/#791-2020-01-06","text":"(websocket client) better error propagation when errors are detected while sending data (ws send) detect failures to send big files, terminate in those cases and report error","title":"[7.9.1] - 2020-01-06"},{"location":"CHANGELOG/#790-2020-01-04","text":"(ws send) add option (-x) to disable per message deflate compression","title":"[7.9.0] - 2020-01-04"},{"location":"CHANGELOG/#789-2020-01-04","text":"(ws send + receive) handle all message types (ping + pong + fragment) / investigate #140","title":"[7.8.9] - 2020-01-04"},{"location":"CHANGELOG/#788-2019-12-28","text":"(mbedtls) fix related to private key file parsing and initialization","title":"[7.8.8] - 2019-12-28"},{"location":"CHANGELOG/#786-2019-12-28","text":"(ws cobra to sentry/statsd) fix for handling null events properly for empty queues + use queue to send data to statsd","title":"[7.8.6] - 2019-12-28"},{"location":"CHANGELOG/#785-2019-12-28","text":"(ws cobra to sentry) handle null events for empty queues","title":"[7.8.5] - 2019-12-28"},{"location":"CHANGELOG/#784-2019-12-27","text":"(ws cobra to sentry) game is picked in a fair manner, so that all games get the same share of sent events","title":"[7.8.4] - 2019-12-27"},{"location":"CHANGELOG/#783-2019-12-27","text":"(ws cobra to sentry) refactor queue related code into a class","title":"[7.8.3] - 2019-12-27"},{"location":"CHANGELOG/#782-2019-12-25","text":"(ws cobra to sentry) bound the queue size used to hold up cobra messages before they are sent to sentry. Default queue size is a 100 messages. Without such limit the program runs out of memory when a subscriber receive a lot of messages that cannot make it to sentry","title":"[7.8.2] - 2019-12-25"},{"location":"CHANGELOG/#781-2019-12-25","text":"(ws client) use correct compilation defines so that spdlog is not used as a header only library (reduce binary size and increase compilation speed)","title":"[7.8.1] - 2019-12-25"},{"location":"CHANGELOG/#780-2019-12-24","text":"(ws client) all commands use spdlog instead of std::cerr or std::cout for logging","title":"[7.8.0] - 2019-12-24"},{"location":"CHANGELOG/#765-2019-12-24","text":"(cobra client) send a websocket ping every 30s to keep the connection opened","title":"[7.6.5] - 2019-12-24"},{"location":"CHANGELOG/#764-2019-12-22","text":"(client) error handling, quote url in error case when failing to parse one (ws) ws_cobra_publish: register callbacks before connecting (doc) mention mbedtls in supported ssl server backend","title":"[7.6.4] - 2019-12-22"},{"location":"CHANGELOG/#763-2019-12-20","text":"(tls) add a simple description of the TLS configuration routine for debugging","title":"[7.6.3] - 2019-12-20"},{"location":"CHANGELOG/#762-2019-12-20","text":"(mbedtls) correct support for using own certificate and private key","title":"[7.6.2] - 2019-12-20"},{"location":"CHANGELOG/#761-2019-12-20","text":"(ws commands) in websocket proxy, disable automatic reconnections + in Dockerfile, use alpine 3.11","title":"[7.6.1] - 2019-12-20"},{"location":"CHANGELOG/#760-2019-12-19","text":"(cobra) Add TLS options to all cobra commands and classes. Add example to the doc.","title":"[7.6.0] - 2019-12-19"},{"location":"CHANGELOG/#758-2019-12-18","text":"(cobra-to-sentry) capture application version from device field","title":"[7.5.8] - 2019-12-18"},{"location":"CHANGELOG/#757-2019-12-18","text":"(tls) Experimental TLS server support with mbedtls (windows) + process cert tlsoption (client + server)","title":"[7.5.7] - 2019-12-18"},{"location":"CHANGELOG/#756-2019-12-18","text":"(tls servers) Make it clear that apple ssl and mbedtls backends do not support SSL in server mode","title":"[7.5.6] - 2019-12-18"},{"location":"CHANGELOG/#755-2019-12-17","text":"(tls options client) TLSOptions struct _validated member should be initialized to false","title":"[7.5.5] - 2019-12-17"},{"location":"CHANGELOG/#754-2019-12-16","text":"(websocket client) improve the error message when connecting to a non websocket server Before: Connection error: Got bad status connecting to example.com:443, status: 200, HTTP Status line: HTTP/1.1 200 OK After: Connection error: Expecting status 101 (Switching Protocol), got 200 status connecting to example.com:443, HTTP Status line: HTTP/1.1 200 OK","title":"[7.5.4] - 2019-12-16"},{"location":"CHANGELOG/#753-2019-12-12","text":"(server) attempt at fixing #131 by using blocking writes in server mode","title":"[7.5.3] - 2019-12-12"},{"location":"CHANGELOG/#752-2019-12-11","text":"(ws) cobra to sentry - created events with sentry tags based on tags present in the cobra messages","title":"[7.5.2] - 2019-12-11"},{"location":"CHANGELOG/#751-2019-12-06","text":"(mac) convert SSL errors to utf8","title":"[7.5.1] - 2019-12-06"},{"location":"CHANGELOG/#750-2019-12-05","text":"(ws) cobra to sentry. Handle Error 429 Too Many Requests and politely wait before sending more data to sentry. In the example below sentry we are sending data too fast, sentry asks us to slow down which we do. Notice how the sent count stop increasing, while we are waiting for 41 seconds. [2019-12-05 15:50:33.759] [info] messages received 2449 sent 3 [2019-12-05 15:50:34.759] [info] messages received 5533 sent 7 [2019-12-05 15:50:35.759] [info] messages received 8612 sent 11 [2019-12-05 15:50:36.759] [info] messages received 11562 sent 15 [2019-12-05 15:50:37.759] [info] messages received 14410 sent 19 [2019-12-05 15:50:38.759] [info] messages received 17236 sent 23 [2019-12-05 15:50:39.282] [error] Error sending data to sentry: 429 [2019-12-05 15:50:39.282] [error] Body: {\"exception\":[{\"stacktrace\":{\"frames\":[{\"filename\":\"WorldScene.lua\",\"function\":\"WorldScene.lua:1935\",\"lineno\":1958},{\"filename\":\"WorldScene.lua\",\"function\":\"onUpdate_WorldCam\",\"lineno\":1921},{\"filename\":\"WorldMapTile.lua\",\"function\":\"__index\",\"lineno\":239}]},\"value\":\"noisytypes: Attempt to call nil(nil,2224139838)!\"}],\"platform\":\"python\",\"sdk\":{\"name\":\"ws\",\"version\":\"1.0.0\"},\"tags\":[[\"game\",\"niso\"],[\"userid\",\"107638363\"],[\"environment\",\"live\"]],\"timestamp\":\"2019-12-05T23:50:39Z\"} [2019-12-05 15:50:39.282] [error] Response: {\"error_name\":\"rate_limit\",\"error\":\"Creation of this event was denied due to rate limiting\"} [2019-12-05 15:50:39.282] [warning] Error 429 - Too Many Requests. ws will sleep and retry after 41 seconds [2019-12-05 15:50:39.760] [info] messages received 18839 sent 25 [2019-12-05 15:50:40.760] [info] messages received 18839 sent 25 [2019-12-05 15:50:41.760] [info] messages received 18839 sent 25 [2019-12-05 15:50:42.761] [info] messages received 18839 sent 25 [2019-12-05 15:50:43.762] [info] messages received 18839 sent 25 [2019-12-05 15:50:44.763] [info] messages received 18839 sent 25 [2019-12-05 15:50:45.768] [info] messages received 18839 sent 25","title":"[7.5.0] - 2019-12-05"},{"location":"CHANGELOG/#745-2019-12-03","text":"(ws) #125 / fix build problem when jsoncpp is not installed locally","title":"[7.4.5] - 2019-12-03"},{"location":"CHANGELOG/#744-2019-12-03","text":"(ws) #125 / cmake detects an already installed jsoncpp and will try to use this one if present","title":"[7.4.4] - 2019-12-03"},{"location":"CHANGELOG/#743-2019-12-03","text":"(http client) use std::unordered_map instead of std::map for HttpParameters and HttpFormDataParameters class aliases","title":"[7.4.3] - 2019-12-03"},{"location":"CHANGELOG/#742-2019-12-02","text":"(client) internal IXDNSLookup class requires a valid cancellation request function callback to be passed in","title":"[7.4.2] - 2019-12-02"},{"location":"CHANGELOG/#741-2019-12-02","text":"(client) fix an overflow in the exponential back off code","title":"[7.4.1] - 2019-12-02"},{"location":"CHANGELOG/#740-2019-11-25","text":"(http client) Add support for multipart HTTP POST upload (ixsentry) Add support for uploading a minidump to sentry","title":"[7.4.0] - 2019-11-25"},{"location":"CHANGELOG/#735-2019-11-20","text":"On Darwin SSL, add ability to skip peer verification.","title":"[7.3.5] - 2019-11-20"},{"location":"CHANGELOG/#734-2019-11-20","text":"32-bits compile fix, courtesy of @fcojavmc","title":"[7.3.4] - 2019-11-20"},{"location":"CHANGELOG/#731-2019-11-16","text":"ws proxy_server / remote server close not forwarded to the client","title":"[7.3.1] - 2019-11-16"},{"location":"CHANGELOG/#730-2019-11-15","text":"New ws command: ws proxy_server .","title":"[7.3.0] - 2019-11-15"},{"location":"CHANGELOG/#722-2019-11-01","text":"Tag a release + minor reformating.","title":"[7.2.2] - 2019-11-01"},{"location":"CHANGELOG/#721-2019-10-26","text":"Add unittest to IXSentryClient to lua backtrace parsing code","title":"[7.2.1] - 2019-10-26"},{"location":"CHANGELOG/#720-2019-10-24","text":"Add cobra_metrics_to_redis sub-command to create streams for each cobra metric event being received.","title":"[7.2.0] - 2019-10-24"},{"location":"CHANGELOG/#710-2019-10-13","text":"Add client support for websocket subprotocol. Look for the new addSubProtocol method for details.","title":"[7.1.0] - 2019-10-13"},{"location":"CHANGELOG/#700-2019-10-01","text":"TLS support in server code, only implemented for the OpenSSL SSL backend for now.","title":"[7.0.0] - 2019-10-01"},{"location":"CHANGELOG/#634-2019-09-30","text":"all ws subcommands propagate tls options to servers (unimplemented) or ws or http client (implemented) (contributed by Matt DeBoer)","title":"[6.3.4] - 2019-09-30"},{"location":"CHANGELOG/#633-2019-09-30","text":"ws has a --version option","title":"[6.3.3] - 2019-09-30"},{"location":"CHANGELOG/#632-2019-09-29","text":"(http + websocket clients) can specify cacert and some other tls options (not implemented on all backend). This makes it so that server certs can finally be validated on windows.","title":"[6.3.2] - 2019-09-29"},{"location":"CHANGELOG/#631-2019-09-29","text":"Add ability to use OpenSSL on apple platforms.","title":"[6.3.1] - 2019-09-29"},{"location":"CHANGELOG/#630-2019-09-28","text":"ixcobra / fix crash in CobraConnection::publishNext when the queue is empty + handle CobraConnection_PublishMode_Batch in CobraMetricsThreadedPublisher","title":"[6.3.0] - 2019-09-28"},{"location":"CHANGELOG/#629-2019-09-27","text":"mbedtls fixes / the unittest now pass on macOS, and hopefully will on Windows/AppVeyor as well.","title":"[6.2.9] - 2019-09-27"},{"location":"CHANGELOG/#628-2019-09-26","text":"Http server: add options to ws https to redirect all requests to a given url. POST requests will get a 200 and an empty response. ws httpd -L --redirect_url https://www.google.com","title":"[6.2.8] - 2019-09-26"},{"location":"CHANGELOG/#627-2019-09-25","text":"Stop having ws send subcommand send a binary message in text mode, which would cause error in make ws_test shell script test.","title":"[6.2.7] - 2019-09-25"},{"location":"CHANGELOG/#626-2019-09-24","text":"Fix 2 race conditions detected with TSan, one in CobraMetricsPublisher::push and another one in WebSocketTransport::sendData (that one was bad).","title":"[6.2.6] - 2019-09-24"},{"location":"CHANGELOG/#625-2019-09-23","text":"Add simple Redis Server which is only capable of doing publish / subscribe. New ws redis_server sub-command to use it. The server is used in the unittest, so that we can run on CI in environment where redis isn not available like github actions env.","title":"[6.2.5] - 2019-09-23"},{"location":"CHANGELOG/#624-2019-09-22","text":"Add options to configure TLS ; contributed by Matt DeBoer. Only implemented for OpenSSL TLS backend for now.","title":"[6.2.4] - 2019-09-22"},{"location":"CHANGELOG/#623-2019-09-21","text":"Fix crash in the Linux unittest in the HTTP client code, in Socket::readBytes Cobra Metrics Publisher code returns the message id of the message that got published, to be used to validated that it got sent properly when receiving an ack.","title":"[6.2.3] - 2019-09-21"},{"location":"CHANGELOG/#622-2019-09-19","text":"In DNS lookup code, make sure the weak pointer we use lives through the expected scope (if branch)","title":"[6.2.2] - 2019-09-19"},{"location":"CHANGELOG/#621-2019-09-17","text":"On error while doing a client handshake, additionally display port number next to the host name","title":"[6.2.1] - 2019-09-17"},{"location":"CHANGELOG/#620-2019-09-09","text":"websocket and http server: server does not close the bound client socket in many cases improve some websocket error messages add a utility function with unittest to parse status line and stop using scanf which triggers warnings on Windows update ws CLI11 (our command line argument parsing library) to the latest, which fix a compiler bug about optional","title":"[6.2.0] - 2019-09-09"},{"location":"CHANGELOG/#610-2019-09-08","text":"move poll wrapper on top of select (only used on Windows) to the ix namespace","title":"[6.1.0] - 2019-09-08"},{"location":"CHANGELOG/#601-2019-09-05","text":"add cobra metrics publisher + server unittest add cobra client + server unittest ws snake (cobra simple server) add basic support for unsubscription + subscribe send the proper subscription data + redis client subscription can be cancelled IXCobraConnection / pdu handlers can crash if they receive json data which is not an object","title":"[6.0.1] - 2019-09-05"},{"location":"CHANGELOG/#600-2019-09-04","text":"all client autobahn test should pass ! zlib/deflate has a bug with windowsbits == 8, so we silently upgrade it to 9/ (fix autobahn test 13.X which uses 8 for the windows size)","title":"[6.0.0] - 2019-09-04"},{"location":"CHANGELOG/#520-2019-09-04","text":"Fragmentation: for sent messages which are compressed, the continuation fragments should not have the rsv1 bit set (fix all autobahn tests for zlib compression 12.X) Websocket Server / do a case insensitive string search when looking for an Upgrade header whose value is websocket. (some client use WebSocket with some upper-case characters)","title":"[5.2.0] - 2019-09-04"},{"location":"CHANGELOG/#519-2019-09-03","text":"ws autobahn / report progress with spdlog::info to get timing info ws autobahn / use condition variables for stopping test case + add more logging on errors","title":"[5.1.9] - 2019-09-03"},{"location":"CHANGELOG/#518-2019-09-03","text":"Per message deflate/compression: handle fragmented messages (fix autobahn test: 12.1.X and probably others)","title":"[5.1.8] - 2019-09-03"},{"location":"CHANGELOG/#517-2019-09-03","text":"Receiving invalid UTF-8 TEXT message should fail and close the connection (fix remaining autobahn test: 6.X UTF-8 Handling)","title":"[5.1.7] - 2019-09-03"},{"location":"CHANGELOG/#516-2019-09-03","text":"Sending invalid UTF-8 TEXT message should fail and close the connection (fix remaining autobahn test: 6.X UTF-8 Handling) Fix failing unittest which was sending binary data in text mode with WebSocket::send to call properly call WebSocket::sendBinary instead. Validate that the reason is proper utf-8. (fix autobahn test 7.5.1) Validate close codes. Autobahn 7.9.*","title":"[5.1.6] - 2019-09-03"},{"location":"CHANGELOG/#515-2019-09-03","text":"Framentation: data and continuation blocks received out of order (fix autobahn test: 5.9 through 5.20 Fragmentation)","title":"[5.1.5] - 2019-09-03"},{"location":"CHANGELOG/#514-2019-09-03","text":"Sending invalid UTF-8 TEXT message should fail and close the connection (fix tons of autobahn test: 6.X UTF-8 Handling)","title":"[5.1.4] - 2019-09-03"},{"location":"CHANGELOG/#513-2019-09-03","text":"Message type (TEXT or BINARY) is invalid for received fragmented messages (fix autobahn test: 5.3 through 5.8 Fragmentation)","title":"[5.1.3] - 2019-09-03"},{"location":"CHANGELOG/#512-2019-09-02","text":"Ping and Pong messages cannot be fragmented (fix autobahn test: 5.1 and 5.2 Fragmentation)","title":"[5.1.2] - 2019-09-02"},{"location":"CHANGELOG/#511-2019-09-01","text":"Close connections when reserved bits are used (fix autobahn test: 3.X Reserved Bits)","title":"[5.1.1] - 2019-09-01"},{"location":"CHANGELOG/#510-2019-08-31","text":"ws autobahn / Add code to test websocket client compliance with the autobahn test-suite add utf-8 validation code, not hooked up properly yet Ping received with a payload too large (> 125 bytes) trigger a connection closure cobra / add tracking about published messages cobra / publish returns a message id, that can be used when cobra / new message type in the message received handler when publish/ok is received (can be used to implement an ack system).","title":"[5.1.0] - 2019-08-31"},{"location":"CHANGELOG/#509-2019-08-30","text":"User-Agent header is set when not specified. New option to cap the max wait between reconnection attempts. Still default to 10s. (setMaxWaitBetweenReconnectionRetries). ws connect --max_wait 5000 ws://example.com # will only wait 5 seconds max between reconnection attempts","title":"[5.0.9] - 2019-08-30"},{"location":"CHANGELOG/#507-2019-08-23","text":"WebSocket: add new option to pass in extra HTTP headers when connecting. ws connect add new option (-H, works like curl ) to pass in extra HTTP headers when connecting If you run against ws echo_server you will see the headers being received printed in the terminal. ws connect -H \"foo: bar\" -H \"baz: buz\" ws://127.0.0.1:8008 CobraConnection: sets a unique id field for all messages sent to cobra . CobraConnection: sets a counter as a field for each event published.","title":"[5.0.7] - 2019-08-23"},{"location":"CHANGELOG/#506-2019-08-22","text":"Windows: silly compile error (poll should be in the global namespace)","title":"[5.0.6] - 2019-08-22"},{"location":"CHANGELOG/#505-2019-08-22","text":"Windows: use select instead of WSAPoll, through a poll wrapper","title":"[5.0.5] - 2019-08-22"},{"location":"CHANGELOG/#504-2019-08-20","text":"Windows build fixes (there was a problem with the use of ::poll that has a different name on Windows (WSAPoll))","title":"[5.0.4] - 2019-08-20"},{"location":"CHANGELOG/#503-2019-08-14","text":"CobraMetricThreadedPublisher _enable flag is an atomic, and CobraMetricsPublisher is enabled by default","title":"[5.0.3] - 2019-08-14"},{"location":"CHANGELOG/#502-2019-08-01","text":"ws cobra_subscribe has a new -q (quiet) option ws cobra_subscribe knows to and display msg stats (count and # of messages received per second) ws cobra_subscribe, cobra_to_statsd and cobra_to_sentry commands have a new option, --filter to restrict the events they want to receive","title":"[5.0.2] - 2019-08-01"},{"location":"CHANGELOG/#501-2019-07-25","text":"ws connect command has a new option to send in binary mode (still default to text) ws connect command has readline history thanks to libnoise-cpp. Now ws connect one can use using arrows to lookup previous sent messages and edit them","title":"[5.0.1] - 2019-07-25"},{"location":"CHANGELOG/#500-2019-06-23","text":"","title":"[5.0.0] - 2019-06-23"},{"location":"CHANGELOG/#changed","text":"New HTTP server / still very early. ws gained a new command, httpd can run a simple webserver serving local files. IXDNSLookup. Uses weak pointer + smart_ptr + shared_from_this instead of static sets + mutex to handle object going away before dns lookup has resolved cobra_to_sentry / backtraces are reversed and line number is not extracted correctly mbedtls and zlib are searched with find_package, and we use the vendored version if nothing is found travis CI uses g++ on Linux","title":"Changed"},{"location":"CHANGELOG/#400-2019-06-09","text":"","title":"[4.0.0] - 2019-06-09"},{"location":"CHANGELOG/#changed_1","text":"WebSocket::send() sends message in TEXT mode by default WebSocketMessage sets a new binary field, which tells whether the received incoming message is binary or text WebSocket::send takes a third arg, binary which default to true (can be text too) WebSocket callback only take one object, a const ix::WebSocketMessagePtr& msg Add explicit WebSocket::sendBinary method New headers + WebSocketMessage class to hold message data, still not used across the board Add test/compatibility folder with small servers and clients written in different languages and different libraries to test compatibility. ws echo_server has a -g option to print a greeting message on connect IXSocketMbedTLS: better error handling in close and connect","title":"Changed"},{"location":"CHANGELOG/#312-2019-06-06","text":"","title":"[3.1.2] - 2019-06-06"},{"location":"CHANGELOG/#added","text":"ws connect has a -x option to disable per message deflate Add WebSocket::disablePerMessageDeflate() option.","title":"Added"},{"location":"CHANGELOG/#300-2019-06-xx","text":"","title":"[3.0.0] - 2019-06-xx"},{"location":"CHANGELOG/#changed_2","text":"TLS, aka SSL works on Windows (websocket and http clients) ws command line tool build on Windows Async API for HttpClient HttpClient API changed to use shared_ptr for response and request","title":"Changed"},{"location":"build/","text":"Build CMake CMakefiles for the library and the examples are available. This library has few dependencies, so it is possible to just add the source files into your project. Otherwise the usual way will suffice. mkdir build # make a build dir so that you can build out of tree. cd build cmake -DUSE_TLS=1 .. make -j make install # will install to /usr/local on Unix, on macOS it is a good idea to sudo chown -R `whoami`:staff /usr/local Headers and a static library will be installed to the target dir. There is a unittest which can be executed by typing make test . Options for building: -DUSE_TLS=1 will enable TLS support -DUSE_MBED_TLS=1 will use mbedlts for the TLS support (default on Windows) -DUSE_WS=1 will build the ws interactive command line tool If you are on Windows, look at the appveyor file that has instructions for building dependencies. It is also possible to externally include the project, so that everything is fetched over the wire when you build like so: ExternalProject_Add( IXWebSocket GIT_REPOSITORY https://github.com/machinezone/IXWebSocket.git ... ) vcpkg It is possible to get IXWebSocket through Microsoft vcpkg . vcpkg install ixwebsocket Conan Conan is currently supported through a recipe in Conan Center ( Bintray entry ). Package reference Conan 1.21.0 and up: ixwebsocket/7.9.2 Earlier versions: ixwebsocket/7.9.2@_/_ Note that the version listed here might not be the latest one. See Bintray or the recipe itself for the latest version. If you're migrating from the previous, custom Bintray remote, note that the package reference has to be lower-case. Docker There is a Dockerfile for running the unittest on Linux, and to run the ws tool. It is also available on the docker registry. docker run bsergean/ws To use docker-compose you must make a docker container first. $ make docker ... $ docker compose up & ... $ docker exec -it ixwebsocket_ws_1 bash app@ca2340eb9106:~$ ws --help ws is a websocket tool ...","title":"Build"},{"location":"build/#build","text":"","title":"Build"},{"location":"build/#cmake","text":"CMakefiles for the library and the examples are available. This library has few dependencies, so it is possible to just add the source files into your project. Otherwise the usual way will suffice. mkdir build # make a build dir so that you can build out of tree. cd build cmake -DUSE_TLS=1 .. make -j make install # will install to /usr/local on Unix, on macOS it is a good idea to sudo chown -R `whoami`:staff /usr/local Headers and a static library will be installed to the target dir. There is a unittest which can be executed by typing make test . Options for building: -DUSE_TLS=1 will enable TLS support -DUSE_MBED_TLS=1 will use mbedlts for the TLS support (default on Windows) -DUSE_WS=1 will build the ws interactive command line tool If you are on Windows, look at the appveyor file that has instructions for building dependencies. It is also possible to externally include the project, so that everything is fetched over the wire when you build like so: ExternalProject_Add( IXWebSocket GIT_REPOSITORY https://github.com/machinezone/IXWebSocket.git ... )","title":"CMake"},{"location":"build/#vcpkg","text":"It is possible to get IXWebSocket through Microsoft vcpkg . vcpkg install ixwebsocket","title":"vcpkg"},{"location":"build/#conan","text":"Conan is currently supported through a recipe in Conan Center ( Bintray entry ). Package reference Conan 1.21.0 and up: ixwebsocket/7.9.2 Earlier versions: ixwebsocket/7.9.2@_/_ Note that the version listed here might not be the latest one. See Bintray or the recipe itself for the latest version. If you're migrating from the previous, custom Bintray remote, note that the package reference has to be lower-case.","title":"Conan"},{"location":"build/#docker","text":"There is a Dockerfile for running the unittest on Linux, and to run the ws tool. It is also available on the docker registry. docker run bsergean/ws To use docker-compose you must make a docker container first. $ make docker ... $ docker compose up & ... $ docker exec -it ixwebsocket_ws_1 bash app@ca2340eb9106:~$ ws --help ws is a websocket tool ...","title":"Docker"},{"location":"cobra/","text":"General cobra is a real time messaging server. The ws utility can run a cobra server (named snake), and has client to publish and subscribe to a cobra server. Bring up 3 terminals and run a server, a publisher and a subscriber in each one. As you publish data you should see it being received by the subscriber. You can run redis-cli MONITOR too to see how redis is being used. Server You will need to have a redis server running locally. To run the server: $ cd <ixwebsocket-top-level-folder>/ixsnake/ixsnake $ ws snake { \"apps\": { \"FC2F10139A2BAc53BB72D9db967b024f\": { \"roles\": { \"_sub\": { \"secret\": \"66B1dA3ED5fA074EB5AE84Dd8CE3b5ba\" }, \"_pub\": { \"secret\": \"1c04DB8fFe76A4EeFE3E318C72d771db\" } } } } } redis host: 127.0.0.1 redis password: redis port: 6379 Publisher $ cd <ixwebsocket-top-level-folder>/ws $ ws cobra_publish --appkey FC2F10139A2BAc53BB72D9db967b024f --endpoint ws://127.0.0.1:8008 --rolename _pub --rolesecret 1c04DB8fFe76A4EeFE3E318C72d771db test_channel cobraMetricsSample.json [2019-11-27 09:06:12.980] [info] Publisher connected [2019-11-27 09:06:12.980] [info] Connection: Upgrade [2019-11-27 09:06:12.980] [info] Sec-WebSocket-Accept: zTtQKMKbvwjdivURplYXwCVUCWM= [2019-11-27 09:06:12.980] [info] Sec-WebSocket-Extensions: permessage-deflate; server_max_window_bits=15; client_max_window_bits=15 [2019-11-27 09:06:12.980] [info] Server: ixwebsocket/7.4.0 macos ssl/DarwinSSL zlib 1.2.11 [2019-11-27 09:06:12.980] [info] Upgrade: websocket [2019-11-27 09:06:12.982] [info] Publisher authenticated [2019-11-27 09:06:12.982] [info] Published msg 3 [2019-11-27 09:06:12.982] [info] Published message id 3 acked Subscriber $ ws cobra_subscribe --appkey FC2F10139A2BAc53BB72D9db967b024f --endpoint ws://127.0.0.1:8008 --rolename _pub --rolesecret 1c04DB8fFe76A4EeFE3E318C72d771db test_channel #messages 0 msg/s 0 [2019-11-27 09:07:39.341] [info] Subscriber connected [2019-11-27 09:07:39.341] [info] Connection: Upgrade [2019-11-27 09:07:39.341] [info] Sec-WebSocket-Accept: 9vkQWofz49qMCUlTSptCCwHWm+Q= [2019-11-27 09:07:39.341] [info] Sec-WebSocket-Extensions: permessage-deflate; server_max_window_bits=15; client_max_window_bits=15 [2019-11-27 09:07:39.341] [info] Server: ixwebsocket/7.4.0 macos ssl/DarwinSSL zlib 1.2.11 [2019-11-27 09:07:39.341] [info] Upgrade: websocket [2019-11-27 09:07:39.342] [info] Subscriber authenticated [2019-11-27 09:07:39.345] [info] Subscriber: subscribed to channel test_channel #messages 0 msg/s 0 #messages 0 msg/s 0 #messages 0 msg/s 0 {\"baz\":123,\"foo\":\"bar\"} #messages 1 msg/s 1 #messages 1 msg/s 0 #messages 1 msg/s 0 {\"baz\":123,\"foo\":\"bar\"} {\"baz\":123,\"foo\":\"bar\"} #messages 3 msg/s 2 #messages 3 msg/s 0 {\"baz\":123,\"foo\":\"bar\"} #messages 4 msg/s 1 ^C","title":"Cobra"},{"location":"cobra/#general","text":"cobra is a real time messaging server. The ws utility can run a cobra server (named snake), and has client to publish and subscribe to a cobra server. Bring up 3 terminals and run a server, a publisher and a subscriber in each one. As you publish data you should see it being received by the subscriber. You can run redis-cli MONITOR too to see how redis is being used.","title":"General"},{"location":"cobra/#server","text":"You will need to have a redis server running locally. To run the server: $ cd <ixwebsocket-top-level-folder>/ixsnake/ixsnake $ ws snake { \"apps\": { \"FC2F10139A2BAc53BB72D9db967b024f\": { \"roles\": { \"_sub\": { \"secret\": \"66B1dA3ED5fA074EB5AE84Dd8CE3b5ba\" }, \"_pub\": { \"secret\": \"1c04DB8fFe76A4EeFE3E318C72d771db\" } } } } } redis host: 127.0.0.1 redis password: redis port: 6379","title":"Server"},{"location":"cobra/#publisher","text":"$ cd <ixwebsocket-top-level-folder>/ws $ ws cobra_publish --appkey FC2F10139A2BAc53BB72D9db967b024f --endpoint ws://127.0.0.1:8008 --rolename _pub --rolesecret 1c04DB8fFe76A4EeFE3E318C72d771db test_channel cobraMetricsSample.json [2019-11-27 09:06:12.980] [info] Publisher connected [2019-11-27 09:06:12.980] [info] Connection: Upgrade [2019-11-27 09:06:12.980] [info] Sec-WebSocket-Accept: zTtQKMKbvwjdivURplYXwCVUCWM= [2019-11-27 09:06:12.980] [info] Sec-WebSocket-Extensions: permessage-deflate; server_max_window_bits=15; client_max_window_bits=15 [2019-11-27 09:06:12.980] [info] Server: ixwebsocket/7.4.0 macos ssl/DarwinSSL zlib 1.2.11 [2019-11-27 09:06:12.980] [info] Upgrade: websocket [2019-11-27 09:06:12.982] [info] Publisher authenticated [2019-11-27 09:06:12.982] [info] Published msg 3 [2019-11-27 09:06:12.982] [info] Published message id 3 acked","title":"Publisher"},{"location":"cobra/#subscriber","text":"$ ws cobra_subscribe --appkey FC2F10139A2BAc53BB72D9db967b024f --endpoint ws://127.0.0.1:8008 --rolename _pub --rolesecret 1c04DB8fFe76A4EeFE3E318C72d771db test_channel #messages 0 msg/s 0 [2019-11-27 09:07:39.341] [info] Subscriber connected [2019-11-27 09:07:39.341] [info] Connection: Upgrade [2019-11-27 09:07:39.341] [info] Sec-WebSocket-Accept: 9vkQWofz49qMCUlTSptCCwHWm+Q= [2019-11-27 09:07:39.341] [info] Sec-WebSocket-Extensions: permessage-deflate; server_max_window_bits=15; client_max_window_bits=15 [2019-11-27 09:07:39.341] [info] Server: ixwebsocket/7.4.0 macos ssl/DarwinSSL zlib 1.2.11 [2019-11-27 09:07:39.341] [info] Upgrade: websocket [2019-11-27 09:07:39.342] [info] Subscriber authenticated [2019-11-27 09:07:39.345] [info] Subscriber: subscribed to channel test_channel #messages 0 msg/s 0 #messages 0 msg/s 0 #messages 0 msg/s 0 {\"baz\":123,\"foo\":\"bar\"} #messages 1 msg/s 1 #messages 1 msg/s 0 #messages 1 msg/s 0 {\"baz\":123,\"foo\":\"bar\"} {\"baz\":123,\"foo\":\"bar\"} #messages 3 msg/s 2 #messages 3 msg/s 0 {\"baz\":123,\"foo\":\"bar\"} #messages 4 msg/s 1 ^C","title":"Subscriber"},{"location":"design/","text":"Implementation details Per Message Deflate compression. The per message deflate compression option is supported. It can lead to very nice bandbwith savings (20x !) if your messages are similar, which is often the case for example for chat applications. All features of the spec should be supported. TLS/SSL Connections can be optionally secured and encrypted with TLS/SSL when using a wss:// endpoint, or using normal un-encrypted socket with ws:// endpoints. AppleSSL is used on iOS and macOS, OpenSSL and mbedTLS can be used on Android, Linux and Windows. If you are using OpenSSL, try to be on a version higher than 1.1.x as there there are thread safety problems with 1.0.x. Polling and background thread work No manual polling to fetch data is required. Data is sent and received instantly by using a background thread for receiving data and the select system call to be notified by the OS of incoming data. No timeout is used for select so that the background thread is only woken up when data is available, to optimize battery life. This is also the recommended way of using select according to the select tutorial, section select law . Read and Writes to the socket are non blocking. Data is sent right away and not enqueued by writing directly to the socket, which is possible since system socket implementations allow concurrent read/writes. However concurrent writes need to be protected with mutex. Automatic reconnection If the remote end (server) breaks the connection, the code will try to perpetually reconnect, by using an exponential backoff strategy, capped at one retry every 10 seconds. This behavior can be disabled. Large messages Large frames are broken up into smaller chunks or messages to avoid filling up the os tcp buffers, which is permitted thanks to WebSocket fragmentation . Messages up to 1G were sent and received succesfully. Testing The library has an interactive tool which is handy for testing compatibility ith other libraries. We have tested our client against Python, Erlang, Node.js, and C++ websocket server libraries. The unittest tries to be comprehensive, and has been running on multiple platforms, with different sanitizers such as a thread sanitizer to catch data races or the undefined behavior sanitizer. The regression test is running after each commit on github actions for multiple configurations. Linux macOS with thread sanitizer macOS, with OpenSSL, with thread sanitizer macOS, with MbedTLS, with thread sanitizer Windows, with MbedTLS (the unittest is not run yet) Limitations On Windows and Android certificate validation needs to be setup so that SocketTLSOptions.caFile point to a pem file, such as the one distributed by Firefox. Unless that setup is done connecting to a wss endpoint will display an error. On Windows with mbedtls the message will contain error in handshake : X509 - Certificate verification failed, e.g. CRL, CA or signature check failed . There is no convenient way to embed a ca cert. Automatic reconnection works at the TCP socket level, and will detect remote end disconnects. However, if the device/computer network become unreachable (by turning off wifi), it is quite hard to reliably and timely detect it at the socket level using recv and send error codes. Here is a good discussion on the subject. This behavior is consistent with other runtimes such as node.js. One way to detect a disconnected device with low level C code is to do a name resolution with DNS but this can be expensive. Mobile devices have good and reliable API to do that. The server code is using select to detect incoming data, and creates one OS thread per connection. This is not as scalable as strategies using epoll or kqueue. C++ code organization Here is a simplistic diagram which explains how the code is structured in term of class/modules. +-----------------------+ --- Public | | Start the receiving Background thread. Auto reconnection. Simple websocket Ping. | IXWebSocket | Interface used by C++ test clients. No IX dependencies. | | +-----------------------+ | | | IXWebSocketServer | Run a server and give each connections its own WebSocket object. | | Each connection is handled in a new OS thread. | | +-----------------------+ --- Private | | | IXWebSocketTransport | Low level websocket code, framing, managing raw socket. Adapted from easywsclient. | | +-----------------------+ | | | IXWebSocketHandshake | Establish the connection between client and server. | | +-----------------------+ | | | IXWebSocket | ws:// Unencrypted Socket handler | IXWebSocketAppleSSL | wss:// TLS encrypted Socket AppleSSL handler. Used on iOS and macOS | IXWebSocketOpenSSL | wss:// TLS encrypted Socket OpenSSL handler. Used on Android and Linux | | Can be used on macOS too. +-----------------------+ | | | IXSocketConnect | Connect to the remote host (client). | | +-----------------------+ | | | IXDNSLookup | Does DNS resolution asynchronously so that it can be interrupted. | | +-----------------------+","title":"Design"},{"location":"design/#implementation-details","text":"","title":"Implementation details"},{"location":"design/#per-message-deflate-compression","text":"The per message deflate compression option is supported. It can lead to very nice bandbwith savings (20x !) if your messages are similar, which is often the case for example for chat applications. All features of the spec should be supported.","title":"Per Message Deflate compression."},{"location":"design/#tlsssl","text":"Connections can be optionally secured and encrypted with TLS/SSL when using a wss:// endpoint, or using normal un-encrypted socket with ws:// endpoints. AppleSSL is used on iOS and macOS, OpenSSL and mbedTLS can be used on Android, Linux and Windows. If you are using OpenSSL, try to be on a version higher than 1.1.x as there there are thread safety problems with 1.0.x.","title":"TLS/SSL"},{"location":"design/#polling-and-background-thread-work","text":"No manual polling to fetch data is required. Data is sent and received instantly by using a background thread for receiving data and the select system call to be notified by the OS of incoming data. No timeout is used for select so that the background thread is only woken up when data is available, to optimize battery life. This is also the recommended way of using select according to the select tutorial, section select law . Read and Writes to the socket are non blocking. Data is sent right away and not enqueued by writing directly to the socket, which is possible since system socket implementations allow concurrent read/writes. However concurrent writes need to be protected with mutex.","title":"Polling and background thread work"},{"location":"design/#automatic-reconnection","text":"If the remote end (server) breaks the connection, the code will try to perpetually reconnect, by using an exponential backoff strategy, capped at one retry every 10 seconds. This behavior can be disabled.","title":"Automatic reconnection"},{"location":"design/#large-messages","text":"Large frames are broken up into smaller chunks or messages to avoid filling up the os tcp buffers, which is permitted thanks to WebSocket fragmentation . Messages up to 1G were sent and received succesfully.","title":"Large messages"},{"location":"design/#testing","text":"The library has an interactive tool which is handy for testing compatibility ith other libraries. We have tested our client against Python, Erlang, Node.js, and C++ websocket server libraries. The unittest tries to be comprehensive, and has been running on multiple platforms, with different sanitizers such as a thread sanitizer to catch data races or the undefined behavior sanitizer. The regression test is running after each commit on github actions for multiple configurations. Linux macOS with thread sanitizer macOS, with OpenSSL, with thread sanitizer macOS, with MbedTLS, with thread sanitizer Windows, with MbedTLS (the unittest is not run yet)","title":"Testing"},{"location":"design/#limitations","text":"On Windows and Android certificate validation needs to be setup so that SocketTLSOptions.caFile point to a pem file, such as the one distributed by Firefox. Unless that setup is done connecting to a wss endpoint will display an error. On Windows with mbedtls the message will contain error in handshake : X509 - Certificate verification failed, e.g. CRL, CA or signature check failed . There is no convenient way to embed a ca cert. Automatic reconnection works at the TCP socket level, and will detect remote end disconnects. However, if the device/computer network become unreachable (by turning off wifi), it is quite hard to reliably and timely detect it at the socket level using recv and send error codes. Here is a good discussion on the subject. This behavior is consistent with other runtimes such as node.js. One way to detect a disconnected device with low level C code is to do a name resolution with DNS but this can be expensive. Mobile devices have good and reliable API to do that. The server code is using select to detect incoming data, and creates one OS thread per connection. This is not as scalable as strategies using epoll or kqueue.","title":"Limitations"},{"location":"design/#c-code-organization","text":"Here is a simplistic diagram which explains how the code is structured in term of class/modules. +-----------------------+ --- Public | | Start the receiving Background thread. Auto reconnection. Simple websocket Ping. | IXWebSocket | Interface used by C++ test clients. No IX dependencies. | | +-----------------------+ | | | IXWebSocketServer | Run a server and give each connections its own WebSocket object. | | Each connection is handled in a new OS thread. | | +-----------------------+ --- Private | | | IXWebSocketTransport | Low level websocket code, framing, managing raw socket. Adapted from easywsclient. | | +-----------------------+ | | | IXWebSocketHandshake | Establish the connection between client and server. | | +-----------------------+ | | | IXWebSocket | ws:// Unencrypted Socket handler | IXWebSocketAppleSSL | wss:// TLS encrypted Socket AppleSSL handler. Used on iOS and macOS | IXWebSocketOpenSSL | wss:// TLS encrypted Socket OpenSSL handler. Used on Android and Linux | | Can be used on macOS too. +-----------------------+ | | | IXSocketConnect | Connect to the remote host (client). | | +-----------------------+ | | | IXDNSLookup | Does DNS resolution asynchronously so that it can be interrupted. | | +-----------------------+","title":"C++ code organization"},{"location":"packages/","text":"Notes on how we can update the different packages for ixwebsocket. VCPKG Visit the releases page on Github. A tag must have been made first. Download the latest entry. $ cd /tmp /tmp$ curl -s -O -L https://github.com/machinezone/IXWebSocket/archive/v9.1.9.tar.gz /tmp$ /tmp$ openssl sha512 v9.1.9.tar.gz SHA512(v9.1.9.tar.gz)= f1fd731b5f6a9ce6d6d10bee22a5d9d9baaa8ea0564d6c4cd7eb91dcb88a45c49b2c7fdb75f8640a3589c1b30cee33ef5df8dcbb55920d013394d1e33ddd3c8e Now go punch those values in the vcpkg ixwebsocket port config files. Here is what the diff look like. vcpkg$ git diff diff --git a/ports/ixwebsocket/CONTROL b/ports/ixwebsocket/CONTROL index db9c2adc9..4acae5c3f 100644 --- a/ports/ixwebsocket/CONTROL +++ b/ports/ixwebsocket/CONTROL @@ -1,5 +1,5 @@ Source: ixwebsocket -Version: 8.0.5 +Version: 9.1.9 Build-Depends: zlib Homepage: https://github.com/machinezone/IXWebSocket Description: Lightweight WebSocket Client and Server + HTTP Client and Server diff --git a/ports/ixwebsocket/portfile.cmake b/ports/ixwebsocket/portfile.cmake index de082aece..68e523a05 100644 --- a/ports/ixwebsocket/portfile.cmake +++ b/ports/ixwebsocket/portfile.cmake @@ -1,8 +1,8 @@ vcpkg_from_github( OUT_SOURCE_PATH SOURCE_PATH REPO machinezone/IXWebSocket - REF v8.0.5 - SHA512 9dcc20d9a0629b92c62a68a8bd7c8206f18dbd9e93289b0b687ec13c478ce9ad1f3563b38c399c8277b0d3812cc78ca725786ba1dedbc3445b9bdb9b689e8add + REF v9.1.9 + SHA512 f1fd731b5f6a9ce6d6d10bee22a5d9d9baaa8ea0564d6c4cd7eb91dcb88a45c49b2c7fdb75f8640a3589c1b30cee33ef5df8dcbb55920d013394d1e33ddd3c8e ) You will need a fork of the vcpkg repo to make a pull request. git fetch upstream git co master git reset --hard upstream/master git push origin master --force Make the pull request (I use a new branch to do that). vcpkg$ git co -b feature/ixwebsocket_9.1.9 M ports/ixwebsocket/CONTROL M ports/ixwebsocket/portfile.cmake Switched to a new branch 'feature/ixwebsocket_9.1.9' vcpkg$ vcpkg$ vcpkg$ git commit -am 'ixwebsocket: update to 9.1.9' [feature/ixwebsocket_9.1.9 8587a4881] ixwebsocket: update to 9.1.9 2 files changed, 3 insertions(+), 3 deletions(-) vcpkg$ vcpkg$ git push fatal: The current branch feature/ixwebsocket_9.1.9 has no upstream branch. To push the current branch and set the remote as upstream, use git push --set-upstream origin feature/ixwebsocket_9.1.9 vcpkg$ git push --set-upstream origin feature/ixwebsocket_9.1.9 Enumerating objects: 11, done. Counting objects: 100% (11/11), done. Delta compression using up to 8 threads Compressing objects: 100% (6/6), done. Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done. Total 6 (delta 4), reused 0 (delta 0) remote: Resolving deltas: 100% (4/4), completed with 4 local objects. remote: remote: Create a pull request for 'feature/ixwebsocket_9.1.9' on GitHub by visiting: remote: https://github.com/bsergean/vcpkg/pull/new/feature/ixwebsocket_9.1.9 remote: To https://github.com/bsergean/vcpkg.git * [new branch] feature/ixwebsocket_9.1.9 -> feature/ixwebsocket_9.1.9 Branch 'feature/ixwebsocket_9.1.9' set up to track remote branch 'feature/ixwebsocket_9.1.9' from 'origin' by rebasing. vcpkg$ Just visit this url, https://github.com/bsergean/vcpkg/pull/new/feature/ixwebsocket_9.1.9, printed on the console, to make the pull request.","title":"Packages"},{"location":"packages/#vcpkg","text":"Visit the releases page on Github. A tag must have been made first. Download the latest entry. $ cd /tmp /tmp$ curl -s -O -L https://github.com/machinezone/IXWebSocket/archive/v9.1.9.tar.gz /tmp$ /tmp$ openssl sha512 v9.1.9.tar.gz SHA512(v9.1.9.tar.gz)= f1fd731b5f6a9ce6d6d10bee22a5d9d9baaa8ea0564d6c4cd7eb91dcb88a45c49b2c7fdb75f8640a3589c1b30cee33ef5df8dcbb55920d013394d1e33ddd3c8e Now go punch those values in the vcpkg ixwebsocket port config files. Here is what the diff look like. vcpkg$ git diff diff --git a/ports/ixwebsocket/CONTROL b/ports/ixwebsocket/CONTROL index db9c2adc9..4acae5c3f 100644 --- a/ports/ixwebsocket/CONTROL +++ b/ports/ixwebsocket/CONTROL @@ -1,5 +1,5 @@ Source: ixwebsocket -Version: 8.0.5 +Version: 9.1.9 Build-Depends: zlib Homepage: https://github.com/machinezone/IXWebSocket Description: Lightweight WebSocket Client and Server + HTTP Client and Server diff --git a/ports/ixwebsocket/portfile.cmake b/ports/ixwebsocket/portfile.cmake index de082aece..68e523a05 100644 --- a/ports/ixwebsocket/portfile.cmake +++ b/ports/ixwebsocket/portfile.cmake @@ -1,8 +1,8 @@ vcpkg_from_github( OUT_SOURCE_PATH SOURCE_PATH REPO machinezone/IXWebSocket - REF v8.0.5 - SHA512 9dcc20d9a0629b92c62a68a8bd7c8206f18dbd9e93289b0b687ec13c478ce9ad1f3563b38c399c8277b0d3812cc78ca725786ba1dedbc3445b9bdb9b689e8add + REF v9.1.9 + SHA512 f1fd731b5f6a9ce6d6d10bee22a5d9d9baaa8ea0564d6c4cd7eb91dcb88a45c49b2c7fdb75f8640a3589c1b30cee33ef5df8dcbb55920d013394d1e33ddd3c8e ) You will need a fork of the vcpkg repo to make a pull request. git fetch upstream git co master git reset --hard upstream/master git push origin master --force Make the pull request (I use a new branch to do that). vcpkg$ git co -b feature/ixwebsocket_9.1.9 M ports/ixwebsocket/CONTROL M ports/ixwebsocket/portfile.cmake Switched to a new branch 'feature/ixwebsocket_9.1.9' vcpkg$ vcpkg$ vcpkg$ git commit -am 'ixwebsocket: update to 9.1.9' [feature/ixwebsocket_9.1.9 8587a4881] ixwebsocket: update to 9.1.9 2 files changed, 3 insertions(+), 3 deletions(-) vcpkg$ vcpkg$ git push fatal: The current branch feature/ixwebsocket_9.1.9 has no upstream branch. To push the current branch and set the remote as upstream, use git push --set-upstream origin feature/ixwebsocket_9.1.9 vcpkg$ git push --set-upstream origin feature/ixwebsocket_9.1.9 Enumerating objects: 11, done. Counting objects: 100% (11/11), done. Delta compression using up to 8 threads Compressing objects: 100% (6/6), done. Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done. Total 6 (delta 4), reused 0 (delta 0) remote: Resolving deltas: 100% (4/4), completed with 4 local objects. remote: remote: Create a pull request for 'feature/ixwebsocket_9.1.9' on GitHub by visiting: remote: https://github.com/bsergean/vcpkg/pull/new/feature/ixwebsocket_9.1.9 remote: To https://github.com/bsergean/vcpkg.git * [new branch] feature/ixwebsocket_9.1.9 -> feature/ixwebsocket_9.1.9 Branch 'feature/ixwebsocket_9.1.9' set up to track remote branch 'feature/ixwebsocket_9.1.9' from 'origin' by rebasing. vcpkg$ Just visit this url, https://github.com/bsergean/vcpkg/pull/new/feature/ixwebsocket_9.1.9, printed on the console, to make the pull request.","title":"VCPKG"},{"location":"usage/","text":"Examples The ws folder countains many interactive programs for chat, file transfers , curl like http clients, demonstrating client and server usage. Windows note To use the network system on Windows, you need to initialize it once with WSAStartup() and clean it up with WSACleanup() . We have helpers for that which you can use, see below. This init would typically take place in your main function. #include <ixwebsocket/IXNetSystem.h> int main() { ix::initNetSystem(); ... ix::uninitNetSystem(); return 0; } WebSocket client API #include <ixwebsocket/IXWebSocket.h> ... // Our websocket object ix::WebSocket webSocket; std::string url(\"ws://localhost:8080/\"); webSocket.setUrl(url); // Optional heart beat, sent every 45 seconds when there is not any traffic // to make sure that load balancers do not kill an idle connection. webSocket.setPingInterval(45); // Per message deflate connection is enabled by default. You can tweak its parameters or disable it webSocket.disablePerMessageDeflate(); // Setup a callback to be fired when a message or an event (open, close, error) is received webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr& msg) { if (msg->type == ix::WebSocketMessageType::Message) { std::cout << msg->str << std::endl; } } ); // Now that our callback is setup, we can start our background thread and receive messages webSocket.start(); // Send a message to the server (default to TEXT mode) webSocket.send(\"hello world\"); // The message can be sent in BINARY mode (useful if you send MsgPack data for example) webSocket.sendBinary(\"some serialized binary data\"); // ... finally ... // Stop the connection webSocket.stop() Sending messages websocket.send(\"foo\") will send a message. If the connection was closed and sending failed, the return value will be set to false. ReadyState getReadyState() returns the state of the connection. There are 4 possible states. ReadyState::Connecting - The connection is not yet open. ReadyState::Open - The connection is open and ready to communicate. ReadyState::Closing - The connection is in the process of closing. ReadyState::Closed - The connection is closed or could not be opened. Open and Close notifications The onMessage event will be fired when the connection is opened or closed. This is similar to the JavaScript browser API , which has open and close events notification that can be registered with the browser addEventListener . webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr& msg) { if (msg->type == ix::WebSocketMessageType::Open) { std::cout << \"send greetings\" << std::endl; // Headers can be inspected (pairs of string/string) std::cout << \"Handshake Headers:\" << std::endl; for (auto it : msg->headers) { std::cout << it.first << \": \" << it.second << std::endl; } } else if (msg->type == ix::WebSocketMessageType::Close) { std::cout << \"disconnected\" << std::endl; // The server can send an explicit code and reason for closing. // This data can be accessed through the closeInfo object. std::cout << msg->closeInfo.code << std::endl; std::cout << msg->closeInfo.reason << std::endl; } } ); Error notification A message will be fired when there is an error with the connection. The message type will be ix::WebSocketMessageType::Error . Multiple fields will be available on the event to describe the error. webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr& msg) { if (msg->type == ix::WebSocketMessageType::Error) { std::stringstream ss; ss << \"Error: \" << msg->errorInfo.reason << std::endl; ss << \"#retries: \" << msg->eventInfo.retries << std::endl; ss << \"Wait time(ms): \" << msg->eventInfo.wait_time << std::endl; ss << \"HTTP Status: \" << msg->eventInfo.http_status << std::endl; std::cout << ss.str() << std::endl; } } ); start, stop websocket.start() connect to the remote server and starts the message receiving background thread. websocket.stop() disconnect from the remote server and closes the background thread. Configuring the remote url The url can be set and queried after a websocket object has been created. You will have to call stop and start if you want to disconnect and connect to that new url. std::string url(\"wss://example.com\"); websocket.configure(url); Ping/Pong support Ping/pong messages are used to implement keep-alive. 2 message types exists to identify ping and pong messages. Note that when a ping message is received, a pong is instantly send back as requested by the WebSocket spec. webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr& msg) { if (msg->type == ix::WebSocketMessageType::Ping || msg->type == ix::WebSocketMessageType::Pong) { std::cout << \"pong data: \" << msg->str << std::endl; } } ); A ping message can be sent to the server, with an optional data string. websocket.ping(\"ping data, optional (empty string is ok): limited to 125 bytes long\"); Heartbeat. You can configure an optional heart beat / keep-alive, sent every 45 seconds when there is no any traffic to make sure that load balancers do not kill an idle connection. webSocket.setPingInterval(45); Supply extra HTTP headers. You can set extra HTTP headers to be sent during the WebSocket handshake. WebSocketHttpHeaders headers; headers[\"foo\"] = \"bar\"; webSocket.setExtraHeaders(headers); Subprotocols You can specify subprotocols to be set during the WebSocket handshake. For more info you can refer to this doc . webSocket.addSubprotocol(\"appProtocol-v1\"); webSocket.addSubprotocol(\"appProtocol-v2\"); The protocol that the server did accept is available in the open info protocol field. std::cout << \"protocol: \" << msg->openInfo.protocol << std::endl; Automatic reconnection Automatic reconnection kicks in when the connection is disconnected without the user consent. This feature is on by default and can be turned off. webSocket.enableAutomaticReconnection(); // turn on webSocket.disableAutomaticReconnection(); // turn off bool enabled = webSocket.isAutomaticReconnectionEnabled(); // query state The technique to calculate wait time is called exponential backoff . Here are the default waiting times between attempts (from connecting with ws connect ws://foo.com ) > Connection error: Got bad status connecting to foo.com, status: 301, HTTP Status line: HTTP/1.1 301 Moved Permanently #retries: 1 Wait time(ms): 100 #retries: 2 Wait time(ms): 200 #retries: 3 Wait time(ms): 400 #retries: 4 Wait time(ms): 800 #retries: 5 Wait time(ms): 1600 #retries: 6 Wait time(ms): 3200 #retries: 7 Wait time(ms): 6400 #retries: 8 Wait time(ms): 10000 The waiting time is capped by default at 10s between 2 attempts, but that value can be changed and queried. webSocket.setMaxWaitBetweenReconnectionRetries(5 * 1000); // 5000ms = 5s uint32_t m = webSocket.getMaxWaitBetweenReconnectionRetries(); WebSocket server API #include <ixwebsocket/IXWebSocketServer.h> ... // Run a server on localhost at a given port. // Bound host name, max connections and listen backlog can also be passed in as parameters. ix::WebSocketServer server(port); server.setOnConnectionCallback( [&server](std::shared_ptr<WebSocket> webSocket, std::shared_ptr<ConnectionState> connectionState) { webSocket->setOnMessageCallback( [webSocket, connectionState, &server](const ix::WebSocketMessagePtr msg) { if (msg->type == ix::WebSocketMessageType::Open) { std::cerr << \"New connection\" << std::endl; // A connection state object is available, and has a default id // You can subclass ConnectionState and pass an alternate factory // to override it. It is useful if you want to store custom // attributes per connection (authenticated bool flag, attributes, etc...) std::cerr << \"id: \" << connectionState->getId() << std::endl; // The uri the client did connect to. std::cerr << \"Uri: \" << msg->openInfo.uri << std::endl; std::cerr << \"Headers:\" << std::endl; for (auto it : msg->openInfo.headers) { std::cerr << it.first << \": \" << it.second << std::endl; } } else if (msg->type == ix::WebSocketMessageType::Message) { // For an echo server, we just send back to the client whatever was received by the server // All connected clients are available in an std::set. See the broadcast cpp example. // Second parameter tells whether we are sending the message in binary or text mode. // Here we send it in the same mode as it was received. webSocket->send(msg->str, msg->binary); } } ); } ); auto res = server.listen(); if (!res.first) { // Error handling return 1; } // Run the server in the background. Server can be stoped by calling server.stop() server.start(); // Block until server.stop() is called. server.wait(); HTTP client API #include <ixwebsocket/IXHttpClient.h> ... // // Preparation // HttpClient httpClient; HttpRequestArgsPtr args = httpClient.createRequest(); // Custom headers can be set WebSocketHttpHeaders headers; headers[\"Foo\"] = \"bar\"; args->extraHeaders = headers; // Timeout options args->connectTimeout = connectTimeout; args->transferTimeout = transferTimeout; // Redirect options args->followRedirects = followRedirects; args->maxRedirects = maxRedirects; // Misc args->compress = compress; // Enable gzip compression args->verbose = verbose; args->logger = [](const std::string& msg) { std::cout << msg; }; // // Synchronous Request // HttpResponsePtr out; std::string url = \"https://www.google.com\"; // HEAD request out = httpClient.head(url, args); // GET request out = httpClient.get(url, args); // POST request with parameters HttpParameters httpParameters; httpParameters[\"foo\"] = \"bar\"; out = httpClient.post(url, httpParameters, args); // POST request with a body out = httpClient.post(url, std::string(\"foo=bar\"), args); // // Result // auto statusCode = response->statusCode; // Can be HttpErrorCode::Ok, HttpErrorCode::UrlMalformed, etc... auto errorCode = response->errorCode; // 200, 404, etc... auto responseHeaders = response->headers; // All the headers in a special case-insensitive unordered_map of (string, string) auto payload = response->payload; // All the bytes from the response as an std::string auto errorMsg = response->errorMsg; // Descriptive error message in case of failure auto uploadSize = response->uploadSize; // Byte count of uploaded data auto downloadSize = response->downloadSize; // Byte count of downloaded data // // Asynchronous Request // bool async = true; HttpClient httpClient(async); auto args = httpClient.createRequest(url, HttpClient::kGet); // Push the request to a queue, bool ok = httpClient.performRequest(args, [](const HttpResponsePtr& response) { // This callback execute in a background thread. Make sure you uses appropriate protection such as mutex auto statusCode = response->statusCode; // acess results } ); // ok will be false if your httpClient is not async HTTP server API #include <ixwebsocket/IXHttpServer.h> ix::HttpServer server(port, hostname); auto res = server.listen(); if (!res.first) { std::cerr << res.second << std::endl; return 1; } server.start(); server.wait(); If you want to handle how requests are processed, implement the setOnConnectionCallback callback, which takes an HttpRequestPtr as input, and returns an HttpResponsePtr. You can look at HttpServer::setDefaultConnectionCallback for a slightly more advanced callback example. setOnConnectionCallback( [this](HttpRequestPtr request, std::shared_ptr<ConnectionState> /*connectionState*/) -> HttpResponsePtr { // Build a string for the response std::stringstream ss; ss << request->method << \" \" << request->uri; std::string content = ss.str(); return std::make_shared<HttpResponse>(200, \"OK\", HttpErrorCode::Ok, WebSocketHttpHeaders(), content); } TLS support and configuration To leverage TLS features, the library must be compiled with the option USE_TLS=1 . If you are using OpenSSL, try to be on a version higher than 1.1.x as there there are thread safety problems with 1.0.x. Then, secure sockets are automatically used when connecting to a wss://* url. Additional TLS options can be configured by passing a ix::SocketTLSOptions instance to the setTLSOptions on ix::WebSocket (or ix::WebSocketServer or ix::HttpServer ) webSocket.setTLSOptions({ .certFile = \"path/to/cert/file.pem\", .keyFile = \"path/to/key/file.pem\", .caFile = \"path/to/trust/bundle/file.pem\", .tls = true // required in server mode }); Specifying certFile and keyFile configures the certificate that will be used to communicate with TLS peers. On a client, this is only necessary for connecting to servers that require a client certificate. On a server, this is necessary for TLS support. Specifying caFile configures the trusted roots bundle file (in PEM format) that will be used to verify peer certificates. - The special value of SYSTEM (the default) indicates that the system-configured trust bundle should be used; this is generally what you want when connecting to any publicly exposed API/server. - The special value of NONE can be used to disable peer verification; this is only recommended to rule out certificate verification when testing connectivity. For a client, specifying caFile can be used if connecting to a server that uses a self-signed cert, or when using a custom CA in an internal environment. For a server, specifying caFile implies that: 1. You require clients to present a certificate 1. It must be signed by one of the trusted roots in the file","title":"Examples"},{"location":"usage/#examples","text":"The ws folder countains many interactive programs for chat, file transfers , curl like http clients, demonstrating client and server usage.","title":"Examples"},{"location":"usage/#windows-note","text":"To use the network system on Windows, you need to initialize it once with WSAStartup() and clean it up with WSACleanup() . We have helpers for that which you can use, see below. This init would typically take place in your main function. #include <ixwebsocket/IXNetSystem.h> int main() { ix::initNetSystem(); ... ix::uninitNetSystem(); return 0; }","title":"Windows note"},{"location":"usage/#websocket-client-api","text":"#include <ixwebsocket/IXWebSocket.h> ... // Our websocket object ix::WebSocket webSocket; std::string url(\"ws://localhost:8080/\"); webSocket.setUrl(url); // Optional heart beat, sent every 45 seconds when there is not any traffic // to make sure that load balancers do not kill an idle connection. webSocket.setPingInterval(45); // Per message deflate connection is enabled by default. You can tweak its parameters or disable it webSocket.disablePerMessageDeflate(); // Setup a callback to be fired when a message or an event (open, close, error) is received webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr& msg) { if (msg->type == ix::WebSocketMessageType::Message) { std::cout << msg->str << std::endl; } } ); // Now that our callback is setup, we can start our background thread and receive messages webSocket.start(); // Send a message to the server (default to TEXT mode) webSocket.send(\"hello world\"); // The message can be sent in BINARY mode (useful if you send MsgPack data for example) webSocket.sendBinary(\"some serialized binary data\"); // ... finally ... // Stop the connection webSocket.stop()","title":"WebSocket client API"},{"location":"usage/#sending-messages","text":"websocket.send(\"foo\") will send a message. If the connection was closed and sending failed, the return value will be set to false.","title":"Sending messages"},{"location":"usage/#readystate","text":"getReadyState() returns the state of the connection. There are 4 possible states. ReadyState::Connecting - The connection is not yet open. ReadyState::Open - The connection is open and ready to communicate. ReadyState::Closing - The connection is in the process of closing. ReadyState::Closed - The connection is closed or could not be opened.","title":"ReadyState"},{"location":"usage/#open-and-close-notifications","text":"The onMessage event will be fired when the connection is opened or closed. This is similar to the JavaScript browser API , which has open and close events notification that can be registered with the browser addEventListener . webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr& msg) { if (msg->type == ix::WebSocketMessageType::Open) { std::cout << \"send greetings\" << std::endl; // Headers can be inspected (pairs of string/string) std::cout << \"Handshake Headers:\" << std::endl; for (auto it : msg->headers) { std::cout << it.first << \": \" << it.second << std::endl; } } else if (msg->type == ix::WebSocketMessageType::Close) { std::cout << \"disconnected\" << std::endl; // The server can send an explicit code and reason for closing. // This data can be accessed through the closeInfo object. std::cout << msg->closeInfo.code << std::endl; std::cout << msg->closeInfo.reason << std::endl; } } );","title":"Open and Close notifications"},{"location":"usage/#error-notification","text":"A message will be fired when there is an error with the connection. The message type will be ix::WebSocketMessageType::Error . Multiple fields will be available on the event to describe the error. webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr& msg) { if (msg->type == ix::WebSocketMessageType::Error) { std::stringstream ss; ss << \"Error: \" << msg->errorInfo.reason << std::endl; ss << \"#retries: \" << msg->eventInfo.retries << std::endl; ss << \"Wait time(ms): \" << msg->eventInfo.wait_time << std::endl; ss << \"HTTP Status: \" << msg->eventInfo.http_status << std::endl; std::cout << ss.str() << std::endl; } } );","title":"Error notification"},{"location":"usage/#start-stop","text":"websocket.start() connect to the remote server and starts the message receiving background thread. websocket.stop() disconnect from the remote server and closes the background thread.","title":"start, stop"},{"location":"usage/#configuring-the-remote-url","text":"The url can be set and queried after a websocket object has been created. You will have to call stop and start if you want to disconnect and connect to that new url. std::string url(\"wss://example.com\"); websocket.configure(url);","title":"Configuring the remote url"},{"location":"usage/#pingpong-support","text":"Ping/pong messages are used to implement keep-alive. 2 message types exists to identify ping and pong messages. Note that when a ping message is received, a pong is instantly send back as requested by the WebSocket spec. webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr& msg) { if (msg->type == ix::WebSocketMessageType::Ping || msg->type == ix::WebSocketMessageType::Pong) { std::cout << \"pong data: \" << msg->str << std::endl; } } ); A ping message can be sent to the server, with an optional data string. websocket.ping(\"ping data, optional (empty string is ok): limited to 125 bytes long\");","title":"Ping/Pong support"},{"location":"usage/#heartbeat","text":"You can configure an optional heart beat / keep-alive, sent every 45 seconds when there is no any traffic to make sure that load balancers do not kill an idle connection. webSocket.setPingInterval(45);","title":"Heartbeat."},{"location":"usage/#supply-extra-http-headers","text":"You can set extra HTTP headers to be sent during the WebSocket handshake. WebSocketHttpHeaders headers; headers[\"foo\"] = \"bar\"; webSocket.setExtraHeaders(headers);","title":"Supply extra HTTP headers."},{"location":"usage/#subprotocols","text":"You can specify subprotocols to be set during the WebSocket handshake. For more info you can refer to this doc . webSocket.addSubprotocol(\"appProtocol-v1\"); webSocket.addSubprotocol(\"appProtocol-v2\"); The protocol that the server did accept is available in the open info protocol field. std::cout << \"protocol: \" << msg->openInfo.protocol << std::endl;","title":"Subprotocols"},{"location":"usage/#automatic-reconnection","text":"Automatic reconnection kicks in when the connection is disconnected without the user consent. This feature is on by default and can be turned off. webSocket.enableAutomaticReconnection(); // turn on webSocket.disableAutomaticReconnection(); // turn off bool enabled = webSocket.isAutomaticReconnectionEnabled(); // query state The technique to calculate wait time is called exponential backoff . Here are the default waiting times between attempts (from connecting with ws connect ws://foo.com ) > Connection error: Got bad status connecting to foo.com, status: 301, HTTP Status line: HTTP/1.1 301 Moved Permanently #retries: 1 Wait time(ms): 100 #retries: 2 Wait time(ms): 200 #retries: 3 Wait time(ms): 400 #retries: 4 Wait time(ms): 800 #retries: 5 Wait time(ms): 1600 #retries: 6 Wait time(ms): 3200 #retries: 7 Wait time(ms): 6400 #retries: 8 Wait time(ms): 10000 The waiting time is capped by default at 10s between 2 attempts, but that value can be changed and queried. webSocket.setMaxWaitBetweenReconnectionRetries(5 * 1000); // 5000ms = 5s uint32_t m = webSocket.getMaxWaitBetweenReconnectionRetries();","title":"Automatic reconnection"},{"location":"usage/#websocket-server-api","text":"#include <ixwebsocket/IXWebSocketServer.h> ... // Run a server on localhost at a given port. // Bound host name, max connections and listen backlog can also be passed in as parameters. ix::WebSocketServer server(port); server.setOnConnectionCallback( [&server](std::shared_ptr<WebSocket> webSocket, std::shared_ptr<ConnectionState> connectionState) { webSocket->setOnMessageCallback( [webSocket, connectionState, &server](const ix::WebSocketMessagePtr msg) { if (msg->type == ix::WebSocketMessageType::Open) { std::cerr << \"New connection\" << std::endl; // A connection state object is available, and has a default id // You can subclass ConnectionState and pass an alternate factory // to override it. It is useful if you want to store custom // attributes per connection (authenticated bool flag, attributes, etc...) std::cerr << \"id: \" << connectionState->getId() << std::endl; // The uri the client did connect to. std::cerr << \"Uri: \" << msg->openInfo.uri << std::endl; std::cerr << \"Headers:\" << std::endl; for (auto it : msg->openInfo.headers) { std::cerr << it.first << \": \" << it.second << std::endl; } } else if (msg->type == ix::WebSocketMessageType::Message) { // For an echo server, we just send back to the client whatever was received by the server // All connected clients are available in an std::set. See the broadcast cpp example. // Second parameter tells whether we are sending the message in binary or text mode. // Here we send it in the same mode as it was received. webSocket->send(msg->str, msg->binary); } } ); } ); auto res = server.listen(); if (!res.first) { // Error handling return 1; } // Run the server in the background. Server can be stoped by calling server.stop() server.start(); // Block until server.stop() is called. server.wait();","title":"WebSocket server API"},{"location":"usage/#http-client-api","text":"#include <ixwebsocket/IXHttpClient.h> ... // // Preparation // HttpClient httpClient; HttpRequestArgsPtr args = httpClient.createRequest(); // Custom headers can be set WebSocketHttpHeaders headers; headers[\"Foo\"] = \"bar\"; args->extraHeaders = headers; // Timeout options args->connectTimeout = connectTimeout; args->transferTimeout = transferTimeout; // Redirect options args->followRedirects = followRedirects; args->maxRedirects = maxRedirects; // Misc args->compress = compress; // Enable gzip compression args->verbose = verbose; args->logger = [](const std::string& msg) { std::cout << msg; }; // // Synchronous Request // HttpResponsePtr out; std::string url = \"https://www.google.com\"; // HEAD request out = httpClient.head(url, args); // GET request out = httpClient.get(url, args); // POST request with parameters HttpParameters httpParameters; httpParameters[\"foo\"] = \"bar\"; out = httpClient.post(url, httpParameters, args); // POST request with a body out = httpClient.post(url, std::string(\"foo=bar\"), args); // // Result // auto statusCode = response->statusCode; // Can be HttpErrorCode::Ok, HttpErrorCode::UrlMalformed, etc... auto errorCode = response->errorCode; // 200, 404, etc... auto responseHeaders = response->headers; // All the headers in a special case-insensitive unordered_map of (string, string) auto payload = response->payload; // All the bytes from the response as an std::string auto errorMsg = response->errorMsg; // Descriptive error message in case of failure auto uploadSize = response->uploadSize; // Byte count of uploaded data auto downloadSize = response->downloadSize; // Byte count of downloaded data // // Asynchronous Request // bool async = true; HttpClient httpClient(async); auto args = httpClient.createRequest(url, HttpClient::kGet); // Push the request to a queue, bool ok = httpClient.performRequest(args, [](const HttpResponsePtr& response) { // This callback execute in a background thread. Make sure you uses appropriate protection such as mutex auto statusCode = response->statusCode; // acess results } ); // ok will be false if your httpClient is not async","title":"HTTP client API"},{"location":"usage/#http-server-api","text":"#include <ixwebsocket/IXHttpServer.h> ix::HttpServer server(port, hostname); auto res = server.listen(); if (!res.first) { std::cerr << res.second << std::endl; return 1; } server.start(); server.wait(); If you want to handle how requests are processed, implement the setOnConnectionCallback callback, which takes an HttpRequestPtr as input, and returns an HttpResponsePtr. You can look at HttpServer::setDefaultConnectionCallback for a slightly more advanced callback example. setOnConnectionCallback( [this](HttpRequestPtr request, std::shared_ptr<ConnectionState> /*connectionState*/) -> HttpResponsePtr { // Build a string for the response std::stringstream ss; ss << request->method << \" \" << request->uri; std::string content = ss.str(); return std::make_shared<HttpResponse>(200, \"OK\", HttpErrorCode::Ok, WebSocketHttpHeaders(), content); }","title":"HTTP server API"},{"location":"usage/#tls-support-and-configuration","text":"To leverage TLS features, the library must be compiled with the option USE_TLS=1 . If you are using OpenSSL, try to be on a version higher than 1.1.x as there there are thread safety problems with 1.0.x. Then, secure sockets are automatically used when connecting to a wss://* url. Additional TLS options can be configured by passing a ix::SocketTLSOptions instance to the setTLSOptions on ix::WebSocket (or ix::WebSocketServer or ix::HttpServer ) webSocket.setTLSOptions({ .certFile = \"path/to/cert/file.pem\", .keyFile = \"path/to/key/file.pem\", .caFile = \"path/to/trust/bundle/file.pem\", .tls = true // required in server mode }); Specifying certFile and keyFile configures the certificate that will be used to communicate with TLS peers. On a client, this is only necessary for connecting to servers that require a client certificate. On a server, this is necessary for TLS support. Specifying caFile configures the trusted roots bundle file (in PEM format) that will be used to verify peer certificates. - The special value of SYSTEM (the default) indicates that the system-configured trust bundle should be used; this is generally what you want when connecting to any publicly exposed API/server. - The special value of NONE can be used to disable peer verification; this is only recommended to rule out certificate verification when testing connectivity. For a client, specifying caFile can be used if connecting to a server that uses a self-signed cert, or when using a custom CA in an internal environment. For a server, specifying caFile implies that: 1. You require clients to present a certificate 1. It must be signed by one of the trusted roots in the file","title":"TLS support and configuration"},{"location":"ws/","text":"General ws is a command line tool that should exercise most of the IXWebSocket code, and provide example code. ws is a websocket tool Usage: ws [OPTIONS] SUBCOMMAND Options: -h,--help Print this help message and exit Subcommands: send Send a file receive Receive a file transfer Broadcasting server connect Connect to a remote server chat Group chat echo_server Echo server broadcast_server Broadcasting server ping Ping pong curl HTTP Client redis_publish Redis publisher redis_subscribe Redis subscriber cobra_subscribe Cobra subscriber cobra_publish Cobra publisher cobra_to_statsd Cobra to statsd cobra_to_sentry Cobra to sentry snake Snake server httpd HTTP server curl The curl subcommand try to be compatible with the curl syntax, to fetch http pages. Making a HEAD request with the -I parameter. $ ws curl -I https://www.google.com/ Accept-Ranges: none Alt-Svc: quic=\":443\"; ma=2592000; v=\"46,43\",h3-Q048=\":443\"; ma=2592000,h3-Q046=\":443\"; ma=2592000,h3-Q043=\":443\"; ma=2592000 Cache-Control: private, max-age=0 Content-Type: text/html; charset=ISO-8859-1 Date: Tue, 08 Oct 2019 21:36:57 GMT Expires: -1 P3P: CP=\"This is not a P3P policy! See g.co/p3phelp for more info.\" Server: gws Set-Cookie: NID=188=ASwfz8GrXQrHCLqAz-AndLOMLcz0rC9yecnf3h0yXZxRL3rTufTU_GDDwERp7qQL7LZ_EB8gCRyPXGERyOSAgaqgnrkoTmvWrwFemRLMaOZ896GrHobi5fV7VLklnSG2w48Gj8xMlwxfP7Z-bX-xR9UZxep1tHM6UmFQdD_GkBE; expires=Wed, 08-Apr-2020 21:36:57 GMT; path=/; domain=.google.com; HttpOnly Transfer-Encoding: chunked Vary: Accept-Encoding X-Frame-Options: SAMEORIGIN X-XSS-Protection: 0 Upload size: 143 Download size: 0 Status: 200 Making a POST request with the -F parameter. $ ws curl -F foo=bar https://httpbin.org/post foo: bar Downloaded 438 bytes out of 438 Access-Control-Allow-Credentials: true Access-Control-Allow-Origin: * Connection: keep-alive Content-Encoding: Content-Length: 438 Content-Type: application/json Date: Tue, 08 Oct 2019 21:47:54 GMT Referrer-Policy: no-referrer-when-downgrade Server: nginx X-Content-Type-Options: nosniff X-Frame-Options: DENY X-XSS-Protection: 1; mode=block Upload size: 219 Download size: 438 Status: 200 payload: { \"args\": {}, \"data\": \"\", \"files\": {}, \"form\": { \"foo\": \"bar\" }, \"headers\": { \"Accept\": \"*/*\", \"Content-Length\": \"7\", \"Content-Type\": \"application/x-www-form-urlencoded\", \"Host\": \"httpbin.org\", \"User-Agent\": \"ixwebsocket/7.0.0 macos ssl/OpenSSL OpenSSL 1.0.2q 20 Nov 2018 zlib 1.2.11\" }, \"json\": null, \"origin\": \"155.94.127.118, 155.94.127.118\", \"url\": \"https://httpbin.org/post\" } Passing in a custom header with -H. $ ws curl -F foo=bar -H 'my_custom_header: baz' https://httpbin.org/post my_custom_header: baz foo: bar Downloaded 470 bytes out of 470 Access-Control-Allow-Credentials: true Access-Control-Allow-Origin: * Connection: keep-alive Content-Encoding: Content-Length: 470 Content-Type: application/json Date: Tue, 08 Oct 2019 21:50:25 GMT Referrer-Policy: no-referrer-when-downgrade Server: nginx X-Content-Type-Options: nosniff X-Frame-Options: DENY X-XSS-Protection: 1; mode=block Upload size: 243 Download size: 470 Status: 200 payload: { \"args\": {}, \"data\": \"\", \"files\": {}, \"form\": { \"foo\": \"bar\" }, \"headers\": { \"Accept\": \"*/*\", \"Content-Length\": \"7\", \"Content-Type\": \"application/x-www-form-urlencoded\", \"Host\": \"httpbin.org\", \"My-Custom-Header\": \"baz\", \"User-Agent\": \"ixwebsocket/7.0.0 macos ssl/OpenSSL OpenSSL 1.0.2q 20 Nov 2018 zlib 1.2.11\" }, \"json\": null, \"origin\": \"155.94.127.118, 155.94.127.118\", \"url\": \"https://httpbin.org/post\" } connect The connect command connects to a websocket endpoint, and starts an interactive prompt. Line editing, such as using the direction keys to fetch the last thing you tried to type) is provided. That command is pretty useful to try to send random data to an endpoint and verify that the service handles it with grace (such as sending invalid json). ws connect wss://echo.websocket.org Type Ctrl-D to exit prompt... Connecting to url: wss://echo.websocket.org > ws_connect: connected Uri: / Handshake Headers: Connection: Upgrade Date: Tue, 08 Oct 2019 21:38:44 GMT Sec-WebSocket-Accept: 2j6LBScZveqrMx1W/GJkCWvZo3M= sec-websocket-extensions: Server: Kaazing Gateway Upgrade: websocket Received ping Received ping Received ping Hello world ! > Received 13 bytes ws_connect: received message: Hello world ! > Hello world ! > Received 13 bytes ws_connect: received message: Hello world ! ws connect 'ws://jeanserge.com/v2?appkey=_pubsub' Type Ctrl-D to exit prompt... Connecting to url: ws://jeanserge.com/v2?appkey=_pubsub > ws_connect: connected Uri: /v2?appkey=_pubsub Handshake Headers: Connection: Upgrade Date: Tue, 08 Oct 2019 21:45:28 GMT Sec-WebSocket-Accept: LYHmjh9Gsu/Yw7aumQqyPObOEV4= Sec-WebSocket-Extensions: permessage-deflate; server_max_window_bits=15; client_max_window_bits=15 Server: Python/3.7 websockets/8.0.2 Upgrade: websocket bababababababab > ws_connect: connection closed: code 1000 reason ws_connect: connected Uri: /v2?appkey=_pubsub Handshake Headers: Connection: Upgrade Date: Tue, 08 Oct 2019 21:45:44 GMT Sec-WebSocket-Accept: I1rqxdLgTU+opPi5/zKPBTuXdLw= Sec-WebSocket-Extensions: permessage-deflate; server_max_window_bits=15; client_max_window_bits=15 Server: Python/3.7 websockets/8.0.2 Upgrade: websocket Websocket proxy ws proxy_server --remote_host ws://127.0.0.1:9000 -v Listening on 127.0.0.1:8008 If you connect to ws://127.0.0.1:8008, the proxy will connect to ws://127.0.0.1:9000 and pass all traffic to this server. File transfer # Start transfer server, which is just a broadcast server at this point ws transfer # running on port 8080. # Start receiver first ws receive ws://localhost:8080 # Then send a file. File will be received and written to disk by the receiver process ws send ws://localhost:8080 /file/to/path HTTP Client $ ws curl --help HTTP Client Usage: ws curl [OPTIONS] url Positionals: url TEXT REQUIRED Connection url Options: -h,--help Print this help message and exit -d TEXT Form data -F TEXT Form data -H TEXT Header --output TEXT Output file -I Send a HEAD request -L Follow redirects --max-redirects INT Max Redirects -v Verbose -O Save output to disk --compress Enable gzip compression --connect-timeout INT Connection timeout --transfer-timeout INT Transfer timeout Cobra client and server cobra is a real time messenging server. ws has several sub-command to interact with cobra. There is also a minimal cobra compatible server named snake available. Below are examples on running a snake server and clients with TLS enabled (the server only works with the OpenSSL and the Mbed TLS backend for now). First, generate certificates. $ cd /path/to/IXWebSocket $ cd ixsnake/ixsnake $ bash ../../ws/generate_certs.sh Generating RSA private key, 2048 bit long modulus .....+++ .................+++ e is 65537 (0x10001) generated ./.certs/trusted-ca-key.pem generated ./.certs/trusted-ca-crt.pem Generating RSA private key, 2048 bit long modulus ..+++ .......................................+++ e is 65537 (0x10001) generated ./.certs/trusted-server-key.pem Signature ok subject=/O=machinezone/O=IXWebSocket/CN=trusted-server Getting CA Private Key generated ./.certs/trusted-server-crt.pem Generating RSA private key, 2048 bit long modulus ...................................+++ ..................................................+++ e is 65537 (0x10001) generated ./.certs/trusted-client-key.pem Signature ok subject=/O=machinezone/O=IXWebSocket/CN=trusted-client Getting CA Private Key generated ./.certs/trusted-client-crt.pem Generating RSA private key, 2048 bit long modulus ..............+++ .......................................+++ e is 65537 (0x10001) generated ./.certs/untrusted-ca-key.pem generated ./.certs/untrusted-ca-crt.pem Generating RSA private key, 2048 bit long modulus ..........+++ ................................................+++ e is 65537 (0x10001) generated ./.certs/untrusted-client-key.pem Signature ok subject=/O=machinezone/O=IXWebSocket/CN=untrusted-client Getting CA Private Key generated ./.certs/untrusted-client-crt.pem Generating RSA private key, 2048 bit long modulus .....................................................................................+++ ...........+++ e is 65537 (0x10001) generated ./.certs/selfsigned-client-key.pem Signature ok subject=/O=machinezone/O=IXWebSocket/CN=selfsigned-client Getting Private key generated ./.certs/selfsigned-client-crt.pem Now run the snake server. $ export certs=.certs $ ws snake --tls --port 8765 --cert-file ${certs}/trusted-server-crt.pem --key-file ${certs}/trusted-server-key.pem --ca-file ${certs}/trusted-ca-crt.pem { \"apps\": { \"FC2F10139A2BAc53BB72D9db967b024f\": { \"roles\": { \"_sub\": { \"secret\": \"66B1dA3ED5fA074EB5AE84Dd8CE3b5ba\" }, \"_pub\": { \"secret\": \"1c04DB8fFe76A4EeFE3E318C72d771db\" } } } } } redis host: 127.0.0.1 redis password: redis port: 6379 As a new connection comes in, such output should be printed [2019-12-19 20:27:19.724] [info] New connection id: 0 Uri: /v2?appkey=_health Headers: Connection: Upgrade Host: 127.0.0.1:8765 Sec-WebSocket-Extensions: permessage-deflate; server_max_window_bits=15; client_max_window_bits=15 Sec-WebSocket-Key: d747B0fE61Db73f7Eh47c0== Sec-WebSocket-Protocol: json Sec-WebSocket-Version: 13 Upgrade: websocket User-Agent: ixwebsocket/7.5.8 macos ssl/OpenSSL OpenSSL 1.0.2q 20 Nov 2018 zlib 1.2.11 To connect and publish a message, do: $ export certs=.certs $ cd /path/to/ws/folder $ ls cobraMetricsSample.json cobraMetricsSample.json $ ws cobra_publish --endpoint wss://127.0.0.1:8765 --appkey FC2F10139A2BAc53BB72D9db967b024f --rolename _pub --rolesecret 1c04DB8fFe76A4EeFE3E318C72d771db --channel foo --cert-file ${certs}/trusted-client-crt.pem --key-file ${certs}/trusted-client-key.pem --ca-file ${certs}/trusted-ca-crt.pem cobraMetricsSample.json [2019-12-19 20:46:42.656] [info] Publisher connected [2019-12-19 20:46:42.657] [info] Connection: Upgrade [2019-12-19 20:46:42.657] [info] Sec-WebSocket-Accept: rs99IFThoBrhSg+k8G4ixH9yaq4= [2019-12-19 20:46:42.657] [info] Sec-WebSocket-Extensions: permessage-deflate; server_max_window_bits=15; client_max_window_bits=15 [2019-12-19 20:46:42.657] [info] Server: ixwebsocket/7.5.8 macos ssl/OpenSSL OpenSSL 1.0.2q 20 Nov 2018 zlib 1.2.11 [2019-12-19 20:46:42.657] [info] Upgrade: websocket [2019-12-19 20:46:42.658] [info] Publisher authenticated [2019-12-19 20:46:42.658] [info] Published msg 3 [2019-12-19 20:46:42.659] [info] Published message id 3 acked To use OpenSSL on macOS, compile with make ws_openssl . First you will have to install OpenSSL libraries, which can be done with Homebrew. Use make ws_mbedtls accordingly to use MbedTLS.","title":"Ws"},{"location":"ws/#general","text":"ws is a command line tool that should exercise most of the IXWebSocket code, and provide example code. ws is a websocket tool Usage: ws [OPTIONS] SUBCOMMAND Options: -h,--help Print this help message and exit Subcommands: send Send a file receive Receive a file transfer Broadcasting server connect Connect to a remote server chat Group chat echo_server Echo server broadcast_server Broadcasting server ping Ping pong curl HTTP Client redis_publish Redis publisher redis_subscribe Redis subscriber cobra_subscribe Cobra subscriber cobra_publish Cobra publisher cobra_to_statsd Cobra to statsd cobra_to_sentry Cobra to sentry snake Snake server httpd HTTP server","title":"General"},{"location":"ws/#curl","text":"The curl subcommand try to be compatible with the curl syntax, to fetch http pages. Making a HEAD request with the -I parameter. $ ws curl -I https://www.google.com/ Accept-Ranges: none Alt-Svc: quic=\":443\"; ma=2592000; v=\"46,43\",h3-Q048=\":443\"; ma=2592000,h3-Q046=\":443\"; ma=2592000,h3-Q043=\":443\"; ma=2592000 Cache-Control: private, max-age=0 Content-Type: text/html; charset=ISO-8859-1 Date: Tue, 08 Oct 2019 21:36:57 GMT Expires: -1 P3P: CP=\"This is not a P3P policy! See g.co/p3phelp for more info.\" Server: gws Set-Cookie: NID=188=ASwfz8GrXQrHCLqAz-AndLOMLcz0rC9yecnf3h0yXZxRL3rTufTU_GDDwERp7qQL7LZ_EB8gCRyPXGERyOSAgaqgnrkoTmvWrwFemRLMaOZ896GrHobi5fV7VLklnSG2w48Gj8xMlwxfP7Z-bX-xR9UZxep1tHM6UmFQdD_GkBE; expires=Wed, 08-Apr-2020 21:36:57 GMT; path=/; domain=.google.com; HttpOnly Transfer-Encoding: chunked Vary: Accept-Encoding X-Frame-Options: SAMEORIGIN X-XSS-Protection: 0 Upload size: 143 Download size: 0 Status: 200 Making a POST request with the -F parameter. $ ws curl -F foo=bar https://httpbin.org/post foo: bar Downloaded 438 bytes out of 438 Access-Control-Allow-Credentials: true Access-Control-Allow-Origin: * Connection: keep-alive Content-Encoding: Content-Length: 438 Content-Type: application/json Date: Tue, 08 Oct 2019 21:47:54 GMT Referrer-Policy: no-referrer-when-downgrade Server: nginx X-Content-Type-Options: nosniff X-Frame-Options: DENY X-XSS-Protection: 1; mode=block Upload size: 219 Download size: 438 Status: 200 payload: { \"args\": {}, \"data\": \"\", \"files\": {}, \"form\": { \"foo\": \"bar\" }, \"headers\": { \"Accept\": \"*/*\", \"Content-Length\": \"7\", \"Content-Type\": \"application/x-www-form-urlencoded\", \"Host\": \"httpbin.org\", \"User-Agent\": \"ixwebsocket/7.0.0 macos ssl/OpenSSL OpenSSL 1.0.2q 20 Nov 2018 zlib 1.2.11\" }, \"json\": null, \"origin\": \"155.94.127.118, 155.94.127.118\", \"url\": \"https://httpbin.org/post\" } Passing in a custom header with -H. $ ws curl -F foo=bar -H 'my_custom_header: baz' https://httpbin.org/post my_custom_header: baz foo: bar Downloaded 470 bytes out of 470 Access-Control-Allow-Credentials: true Access-Control-Allow-Origin: * Connection: keep-alive Content-Encoding: Content-Length: 470 Content-Type: application/json Date: Tue, 08 Oct 2019 21:50:25 GMT Referrer-Policy: no-referrer-when-downgrade Server: nginx X-Content-Type-Options: nosniff X-Frame-Options: DENY X-XSS-Protection: 1; mode=block Upload size: 243 Download size: 470 Status: 200 payload: { \"args\": {}, \"data\": \"\", \"files\": {}, \"form\": { \"foo\": \"bar\" }, \"headers\": { \"Accept\": \"*/*\", \"Content-Length\": \"7\", \"Content-Type\": \"application/x-www-form-urlencoded\", \"Host\": \"httpbin.org\", \"My-Custom-Header\": \"baz\", \"User-Agent\": \"ixwebsocket/7.0.0 macos ssl/OpenSSL OpenSSL 1.0.2q 20 Nov 2018 zlib 1.2.11\" }, \"json\": null, \"origin\": \"155.94.127.118, 155.94.127.118\", \"url\": \"https://httpbin.org/post\" }","title":"curl"},{"location":"ws/#connect","text":"The connect command connects to a websocket endpoint, and starts an interactive prompt. Line editing, such as using the direction keys to fetch the last thing you tried to type) is provided. That command is pretty useful to try to send random data to an endpoint and verify that the service handles it with grace (such as sending invalid json). ws connect wss://echo.websocket.org Type Ctrl-D to exit prompt... Connecting to url: wss://echo.websocket.org > ws_connect: connected Uri: / Handshake Headers: Connection: Upgrade Date: Tue, 08 Oct 2019 21:38:44 GMT Sec-WebSocket-Accept: 2j6LBScZveqrMx1W/GJkCWvZo3M= sec-websocket-extensions: Server: Kaazing Gateway Upgrade: websocket Received ping Received ping Received ping Hello world ! > Received 13 bytes ws_connect: received message: Hello world ! > Hello world ! > Received 13 bytes ws_connect: received message: Hello world ! ws connect 'ws://jeanserge.com/v2?appkey=_pubsub' Type Ctrl-D to exit prompt... Connecting to url: ws://jeanserge.com/v2?appkey=_pubsub > ws_connect: connected Uri: /v2?appkey=_pubsub Handshake Headers: Connection: Upgrade Date: Tue, 08 Oct 2019 21:45:28 GMT Sec-WebSocket-Accept: LYHmjh9Gsu/Yw7aumQqyPObOEV4= Sec-WebSocket-Extensions: permessage-deflate; server_max_window_bits=15; client_max_window_bits=15 Server: Python/3.7 websockets/8.0.2 Upgrade: websocket bababababababab > ws_connect: connection closed: code 1000 reason ws_connect: connected Uri: /v2?appkey=_pubsub Handshake Headers: Connection: Upgrade Date: Tue, 08 Oct 2019 21:45:44 GMT Sec-WebSocket-Accept: I1rqxdLgTU+opPi5/zKPBTuXdLw= Sec-WebSocket-Extensions: permessage-deflate; server_max_window_bits=15; client_max_window_bits=15 Server: Python/3.7 websockets/8.0.2 Upgrade: websocket","title":"connect"},{"location":"ws/#websocket-proxy","text":"ws proxy_server --remote_host ws://127.0.0.1:9000 -v Listening on 127.0.0.1:8008 If you connect to ws://127.0.0.1:8008, the proxy will connect to ws://127.0.0.1:9000 and pass all traffic to this server.","title":"Websocket proxy"},{"location":"ws/#file-transfer","text":"# Start transfer server, which is just a broadcast server at this point ws transfer # running on port 8080. # Start receiver first ws receive ws://localhost:8080 # Then send a file. File will be received and written to disk by the receiver process ws send ws://localhost:8080 /file/to/path","title":"File transfer"},{"location":"ws/#http-client","text":"$ ws curl --help HTTP Client Usage: ws curl [OPTIONS] url Positionals: url TEXT REQUIRED Connection url Options: -h,--help Print this help message and exit -d TEXT Form data -F TEXT Form data -H TEXT Header --output TEXT Output file -I Send a HEAD request -L Follow redirects --max-redirects INT Max Redirects -v Verbose -O Save output to disk --compress Enable gzip compression --connect-timeout INT Connection timeout --transfer-timeout INT Transfer timeout","title":"HTTP Client"},{"location":"ws/#cobra-client-and-server","text":"cobra is a real time messenging server. ws has several sub-command to interact with cobra. There is also a minimal cobra compatible server named snake available. Below are examples on running a snake server and clients with TLS enabled (the server only works with the OpenSSL and the Mbed TLS backend for now). First, generate certificates. $ cd /path/to/IXWebSocket $ cd ixsnake/ixsnake $ bash ../../ws/generate_certs.sh Generating RSA private key, 2048 bit long modulus .....+++ .................+++ e is 65537 (0x10001) generated ./.certs/trusted-ca-key.pem generated ./.certs/trusted-ca-crt.pem Generating RSA private key, 2048 bit long modulus ..+++ .......................................+++ e is 65537 (0x10001) generated ./.certs/trusted-server-key.pem Signature ok subject=/O=machinezone/O=IXWebSocket/CN=trusted-server Getting CA Private Key generated ./.certs/trusted-server-crt.pem Generating RSA private key, 2048 bit long modulus ...................................+++ ..................................................+++ e is 65537 (0x10001) generated ./.certs/trusted-client-key.pem Signature ok subject=/O=machinezone/O=IXWebSocket/CN=trusted-client Getting CA Private Key generated ./.certs/trusted-client-crt.pem Generating RSA private key, 2048 bit long modulus ..............+++ .......................................+++ e is 65537 (0x10001) generated ./.certs/untrusted-ca-key.pem generated ./.certs/untrusted-ca-crt.pem Generating RSA private key, 2048 bit long modulus ..........+++ ................................................+++ e is 65537 (0x10001) generated ./.certs/untrusted-client-key.pem Signature ok subject=/O=machinezone/O=IXWebSocket/CN=untrusted-client Getting CA Private Key generated ./.certs/untrusted-client-crt.pem Generating RSA private key, 2048 bit long modulus .....................................................................................+++ ...........+++ e is 65537 (0x10001) generated ./.certs/selfsigned-client-key.pem Signature ok subject=/O=machinezone/O=IXWebSocket/CN=selfsigned-client Getting Private key generated ./.certs/selfsigned-client-crt.pem Now run the snake server. $ export certs=.certs $ ws snake --tls --port 8765 --cert-file ${certs}/trusted-server-crt.pem --key-file ${certs}/trusted-server-key.pem --ca-file ${certs}/trusted-ca-crt.pem { \"apps\": { \"FC2F10139A2BAc53BB72D9db967b024f\": { \"roles\": { \"_sub\": { \"secret\": \"66B1dA3ED5fA074EB5AE84Dd8CE3b5ba\" }, \"_pub\": { \"secret\": \"1c04DB8fFe76A4EeFE3E318C72d771db\" } } } } } redis host: 127.0.0.1 redis password: redis port: 6379 As a new connection comes in, such output should be printed [2019-12-19 20:27:19.724] [info] New connection id: 0 Uri: /v2?appkey=_health Headers: Connection: Upgrade Host: 127.0.0.1:8765 Sec-WebSocket-Extensions: permessage-deflate; server_max_window_bits=15; client_max_window_bits=15 Sec-WebSocket-Key: d747B0fE61Db73f7Eh47c0== Sec-WebSocket-Protocol: json Sec-WebSocket-Version: 13 Upgrade: websocket User-Agent: ixwebsocket/7.5.8 macos ssl/OpenSSL OpenSSL 1.0.2q 20 Nov 2018 zlib 1.2.11 To connect and publish a message, do: $ export certs=.certs $ cd /path/to/ws/folder $ ls cobraMetricsSample.json cobraMetricsSample.json $ ws cobra_publish --endpoint wss://127.0.0.1:8765 --appkey FC2F10139A2BAc53BB72D9db967b024f --rolename _pub --rolesecret 1c04DB8fFe76A4EeFE3E318C72d771db --channel foo --cert-file ${certs}/trusted-client-crt.pem --key-file ${certs}/trusted-client-key.pem --ca-file ${certs}/trusted-ca-crt.pem cobraMetricsSample.json [2019-12-19 20:46:42.656] [info] Publisher connected [2019-12-19 20:46:42.657] [info] Connection: Upgrade [2019-12-19 20:46:42.657] [info] Sec-WebSocket-Accept: rs99IFThoBrhSg+k8G4ixH9yaq4= [2019-12-19 20:46:42.657] [info] Sec-WebSocket-Extensions: permessage-deflate; server_max_window_bits=15; client_max_window_bits=15 [2019-12-19 20:46:42.657] [info] Server: ixwebsocket/7.5.8 macos ssl/OpenSSL OpenSSL 1.0.2q 20 Nov 2018 zlib 1.2.11 [2019-12-19 20:46:42.657] [info] Upgrade: websocket [2019-12-19 20:46:42.658] [info] Publisher authenticated [2019-12-19 20:46:42.658] [info] Published msg 3 [2019-12-19 20:46:42.659] [info] Published message id 3 acked To use OpenSSL on macOS, compile with make ws_openssl . First you will have to install OpenSSL libraries, which can be done with Homebrew. Use make ws_mbedtls accordingly to use MbedTLS.","title":"Cobra client and server"}]}